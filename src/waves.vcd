$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module $rootio $end
 $upscope $end
 $scope module MAC_unit_tb $end
  $var wire 32 p CLK_PERIOD [31:0] $end
  $var wire 1 k tb_clk $end
  $var wire 1 # tb_nrst $end
  $scope module mac_if $end
   $var wire 32 x data_w [31:0] $end
   $var wire 1 y start $end
   $var wire 1 z count $end
   $var wire 16 , weight [15:0] $end
   $var wire 16 + in_value [15:0] $end
   $var wire 16 ( in_accumulate [15:0] $end
   $var wire 16 j out_accumulate [15:0] $end
  $upscope $end
  $scope module dut $end
   $var wire 1 k clk $end
   $var wire 1 # nRST $end
   $scope module mac_if $end
    $var wire 32 x data_w [31:0] $end
    $var wire 1 y start $end
    $var wire 1 z count $end
    $var wire 16 , weight [15:0] $end
    $var wire 16 + in_value [15:0] $end
    $var wire 16 ( in_accumulate [15:0] $end
    $var wire 16 j out_accumulate [15:0] $end
   $upscope $end
   $var wire 1 $ mul_sign1_out $end
   $var wire 1 % mul_sign2_out $end
   $var wire 1 l mul_carryout_out $end
   $var wire 1 9 mul_sign1_in $end
   $var wire 1 : mul_sign2_in $end
   $var wire 1 ; mul_carryout_in $end
   $var wire 5 & mul_exp1_out [4:0] $end
   $var wire 5 ' mul_exp2_out [4:0] $end
   $var wire 5 < mul_exp1_in [4:0] $end
   $var wire 5 = mul_exp2_in [4:0] $end
   $var wire 13 m mul_product_out [12:0] $end
   $var wire 13 > mul_product_in [12:0] $end
   $var wire 1 ? mul_sign_result $end
   $var wire 5 @ mul_sum_exp [4:0] $end
   $var wire 1 A mul_ovf $end
   $var wire 1 B mul_unf $end
   $var wire 16 C mul_result [15:0] $end
   $var wire 1 D add_sign_shifted_in $end
   $var wire 1 E add_sign_not_shifted_in $end
   $var wire 1 / add_sign_shifted_out $end
   $var wire 1 0 add_sign_not_shifted_out $end
   $var wire 13 1 frac_shifted_out [12:0] $end
   $var wire 13 2 frac_not_shifted_out [12:0] $end
   $var wire 13 F frac_shifted_in [12:0] $end
   $var wire 13 G frac_not_shifted_in [12:0] $end
   $var wire 5 n add_exp_max_out [4:0] $end
   $var wire 5 H add_exp_max_in [4:0] $end
   $var wire 1 I add_sign_out $end
   $var wire 1 J add_sign_in $end
   $var wire 13 K add_sum_out [12:0] $end
   $var wire 13 L add_sum_in [12:0] $end
   $var wire 1 M add_carry_out $end
   $var wire 1 N add_carry_in $end
   $var wire 5 O add_exp_max_s2_out [4:0] $end
   $var wire 5 P add_exp_max_s3_in [4:0] $end
   $var wire 16 Q accumulate_result [15:0] $end
   $var wire 5 R add_flags [4:0] $end
   $scope module add1 $end
    $var wire 16 C floating_point1_in [15:0] $end
    $var wire 16 ( floating_point2_in [15:0] $end
    $var wire 1 / sign_shifted $end
    $var wire 13 1 frac_shifted [12:0] $end
    $var wire 1 0 sign_not_shifted $end
    $var wire 13 2 frac_not_shifted [12:0] $end
    $var wire 5 n exp_max [4:0] $end
    $var wire 5 3 unsigned_exp_diff [4:0] $end
    $var wire 1 4 cmp_out $end
    $var wire 16 5 floating_point_shift [15:0] $end
    $var wire 16 6 floating_point_not_shift [15:0] $end
    $var wire 16 q shifted_floating_point [15:0] $end
    $scope module cmp_exponents $end
     $var wire 5 @ exp1 [4:0] $end
     $var wire 5 ) exp2 [4:0] $end
     $var wire 5 3 u_diff [4:0] $end
     $var wire 1 4 cmp_out $end
     $var wire 6 S u_exp1 [5:0] $end
     $var wire 6 * u_exp2 [5:0] $end
     $var wire 6 7 diff [5:0] $end
    $upscope $end
    $scope module shift_frac_with_smaller_exp $end
     $var wire 13 8 fraction [12:0] $end
     $var wire 5 3 shift_amount [4:0] $end
     $var wire 13 1 result [12:0] $end
    $upscope $end
   $upscope $end
   $scope module add2 $end
    $var wire 13 F frac1 [12:0] $end
    $var wire 1 D sign1 $end
    $var wire 13 G frac2 [12:0] $end
    $var wire 1 E sign2 $end
    $var wire 5 H exp_max_in [4:0] $end
    $var wire 1 I sign_out $end
    $var wire 13 K sum [12:0] $end
    $var wire 1 M carry_out $end
    $var wire 5 O exp_max_out [4:0] $end
    $var wire 14 T frac1_signed [13:0] $end
    $var wire 14 U frac2_signed [13:0] $end
    $var wire 14 V sum_signed [13:0] $end
    $scope module add_signed_fracs $end
     $var wire 14 T frac1 [13:0] $end
     $var wire 14 U frac2 [13:0] $end
     $var wire 14 V sum [13:0] $end
     $var wire 1 M ovf $end
    $upscope $end
    $scope module change_to_signed1 $end
     $var wire 1 D sign $end
     $var wire 13 F frac_unsigned [12:0] $end
     $var wire 14 T frac_signed [13:0] $end
    $upscope $end
    $scope module change_to_signed2 $end
     $var wire 1 E sign $end
     $var wire 13 G frac_unsigned [12:0] $end
     $var wire 14 U frac_signed [13:0] $end
    $upscope $end
    $scope module change_to_unsigned $end
     $var wire 14 V frac_signed [13:0] $end
     $var wire 1 I sign $end
     $var wire 13 K frac_unsigned [12:0] $end
     $var wire 14 W rfrac_signed [13:0] $end
    $upscope $end
   $upscope $end
   $scope module add3 $end
    $var wire 1 r ovf_in $end
    $var wire 1 r unf_in $end
    $var wire 1 r dz $end
    $var wire 1 r inv $end
    $var wire 3 s frm [2:0] $end
    $var wire 5 P exponent_max_in [4:0] $end
    $var wire 1 J sign_in $end
    $var wire 13 L frac_in [12:0] $end
    $var wire 1 N carry_out $end
    $var wire 16 Q floating_point_out [15:0] $end
    $var wire 5 R flags [4:0] $end
    $var wire 1 X inexact $end
    $var wire 1 J sign $end
    $var wire 5 Y exponent [4:0] $end
    $var wire 10 Z frac [9:0] $end
    $var wire 5 [ exp_minus_shift_amount [4:0] $end
    $var wire 13 \ shifted_frac [12:0] $end
    $var wire 5 ] shifted_amount [4:0] $end
    $var wire 5 ^ exp_out [4:0] $end
    $var wire 1 _ ovf $end
    $var wire 1 ` unf $end
    $var wire 12 a round_this [11:0] $end
    $var wire 16 b round_out [15:0] $end
    $var wire 1 c round_flag $end
    $scope module ROUND $end
     $var wire 3 s frm [2:0] $end
     $var wire 1 J sign $end
     $var wire 5 ^ exp_in [4:0] $end
     $var wire 12 a fraction [11:0] $end
     $var wire 16 b round_out [15:0] $end
     $var wire 1 c rounded $end
     $var wire 1 c round_amount $end
     $var wire 3 t RNE [2:0] $end
     $var wire 3 s RZE [2:0] $end
     $var wire 3 u RDN [2:0] $end
     $var wire 3 v RUP [2:0] $end
     $var wire 3 w RMM [2:0] $end
    $upscope $end
    $scope module SUB $end
     $var wire 5 P exp1 [4:0] $end
     $var wire 5 ] shifted_amount [4:0] $end
     $var wire 5 [ result [4:0] $end
     $var wire 6 d u_exp1 [5:0] $end
     $var wire 6 e u_shifted_amount [5:0] $end
     $var wire 6 f u_result [5:0] $end
    $upscope $end
    $scope module shift_left $end
     $var wire 13 L fraction [12:0] $end
     $var wire 13 \ result [12:0] $end
     $var wire 5 ] shifted_amount [4:0] $end
    $upscope $end
   $upscope $end
   $scope module mul1 $end
    $var wire 16 + fp1_in [15:0] $end
    $var wire 16 , fp2_in [15:0] $end
    $var wire 1 $ sign1 $end
    $var wire 1 % sign2 $end
    $var wire 5 & exp1 [4:0] $end
    $var wire 5 ' exp2 [4:0] $end
    $var wire 13 m product [12:0] $end
    $var wire 1 l carry_out $end
    $scope module MUL $end
     $var wire 13 - frac_in1 [12:0] $end
     $var wire 13 . frac_in2 [12:0] $end
     $var wire 13 m frac_out [12:0] $end
     $var wire 1 l overflow $end
     $var wire 26 o frac_out_26b [25:0] $end
    $upscope $end
   $upscope $end
   $scope module mul2 $end
    $var wire 1 9 sign1 $end
    $var wire 1 : sign2 $end
    $var wire 5 < exp1 [4:0] $end
    $var wire 5 = exp2 [4:0] $end
    $var wire 1 ? sign_out $end
    $var wire 5 @ sum_exp [4:0] $end
    $var wire 1 A ovf $end
    $var wire 1 B unf $end
    $var wire 1 ; carry $end
    $scope module add_EXPs $end
     $var wire 1 ; carry $end
     $var wire 5 < exp1 [4:0] $end
     $var wire 5 = exp2 [4:0] $end
     $var wire 5 @ sum [4:0] $end
     $var wire 1 A ovf $end
     $var wire 1 B unf $end
     $var wire 5 g r_exp1 [4:0] $end
     $var wire 5 h r_exp2 [4:0] $end
     $var wire 5 i r_sum [4:0] $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
0#
0$
0%
b00000 &
b00000 '
b0000000000000000 (
b00000 )
b000000 *
b0000000000000000 +
b0000000000000000 ,
b1000000000000 -
b1000000000000 .
0/
00
b0000000000000 1
b1000000000000 2
b10001 3
04
b0000000000000000 5
b0100010000000000 6
b010001 7
b1000000000000 8
09
0:
0;
b00000 <
b00000 =
b0000000000000 >
0?
b10001 @
0A
1B
b0100010000000000 C
0D
0E
b0000000000000 F
b0000000000000 G
b00000 H
0I
0J
b0000000000000 K
b0000000000000 L
0M
0N
b00000 O
b00000 P
b0000000000000000 Q
b00000 R
b010001 S
b00000000000000 T
b00000000000000 U
b00000000000000 V
b00000000000000 W
0X
b00000 Y
b0000000000 Z
b00000 [
b0000000000000 \
b00000 ]
b00000 ^
0_
0`
b000000000000 a
b0000000000000000 b
0c
b000000 d
b000000 e
b000000 f
b10000 g
b10000 h
b00000 i
b0000000000000000 j
0k
0l
b1000000000000 m
b10001 n
b01000000000000000000000000 o
b00000000000000000000000000000001 p
b0000000000000000 q
0r
b001 s
b000 t
b010 u
b011 v
b100 w
b00000000000000000000000000010000 x
0y
0z
#500
1k
#1000
1#
b10010 &
b10000 '
b0100010100000000 (
b10001 )
b010001 *
b0100101110000000 +
b0100000000000000 ,
b1111000000000 -
b1010000000000 1
b00000 3
b0100010100000000 5
b000000 7
b1010000000000 8
0k
b1111000000000 m
b01111000000000000000000000 o
#1500
b1000000000000 1
b1111000000000 2
b00010 3
b0100111110000000 6
b000010 7
b10010 <
b10000 =
b1111000000000 >
b10011 @
0B
b0100111110000000 C
b1010000000000 F
b1000000000000 G
b10001 H
b0010000000000 K
1M
b10001 O
b010011 S
b01010000000000 T
b01000000000000 U
b00010000000000 V
b00010000000000 W
b00010 g
b00000 h
b00010 i
1k
b10011 n
#2000
0k
#2500
b1000000000000 F
b1111000000000 G
b10011 H
b0111000000000 K
b0010000000000 L
1N
b10011 O
b10001 P
b0100100010000000 Q
b01000000000000 T
b01111000000000 U
b00111000000000 V
b00111000000000 W
b10010 Y
b0010000000 Z
b01111 [
b1000000000000 \
b00010 ]
b10010 ^
b001000000000 a
b0100100010000000 b
b010001 d
b000010 e
b001111 f
b0100100010000000 j
1k
#3000
0k
#3500
b0111000000000 L
b10011 P
b0101000111000000 Q
b10100 Y
b0111000000 Z
b10010 [
b1110000000000 \
b00001 ]
b10100 ^
b011100000000 a
b0101000111000000 b
b010011 d
b000001 e
b010010 f
b0101000111000000 j
1k
#4000
0k
#4500
1k
#5000
0k
#5500
1k
#6000
0k
#6500
1k
#7000
0k
