var g_data = {"name":"./src/testbench/cache_bank_bind.sv","src":"`include \"cache_types_pkg.svh\"\n\nmodule confirm_lru_age (\n    input logic CLK, \n    input logic nRST,\n    input logic [2:0] curr_state,\n    input lru_frame [NUM_SETS_PER_BANK-1:0] lru,\n    input logic [BLOCK_INDEX_BIT_LEN-1:0] latched_victim_set_index,\n    input logic [WAYS_LEN-1:0] latched_victim_way_index\n);\n\n  always @ (posedge CLK) begin \n    for (integer set = 0; set < NUM_SETS_PER_BANK; set++) begin\n      for (integer j = 0; j < NUM_WAYS; j++) begin\n        assert (lru[set].age[lru[set].lru_way] >= lru[set].age[j])\n          else $error(\"ASSERTIONERROR: LRU Age is wrong set %0d - (LRU way %0d, age %0d) < (Way %0d, age %0d)!\",\n                      set,  lru[set].lru_way, lru[set].age[lru[set].lru_way], j, lru[set].age[j]);\n      end\n    end\n  end\n\n  property lru_update;\n    @(posedge CLK) disable iff (!nRST)\n    (curr_state == FINISH) |=>\n      ## 1 (lru[$past(latched_victim_set_index, 1)].age[$past(latched_victim_way_index, 1)] == 0);\n  endproperty\n\n  assert property (lru_update)\n    else $error(\"ASSERTIONERROR: Victim way's (set: %0d, way: %0d) age was not reset in FINISH state\", $past(latched_victim_set_index, 1), $past(latched_victim_way_index, 1));\n\nendmodule\n\nmodule confirm_replacement_mshr (\n    input logic CLK,\n    input logic nRST,\n    input logic [2:0] curr_state, \n    input logic [BLOCK_OFF_BIT_LEN-1:0] count_FSM,\n    input logic [BLOCK_INDEX_BIT_LEN-1:0] latched_victim_set_index,\n    input logic [WAYS_LEN-1:0] latched_victim_way_index,\n    input cache_set [NUM_SETS_PER_BANK-1:0] bank, \n    input cache_frame latched_block_pull_buffer,\n    input mshr_reg mshr_entry\n);\n\n  property block_pull_replacement;\n    @(posedge CLK) disable iff (!nRST)\n    ((curr_state == VICTIM_EJECT) && (count_FSM == BLOCK_OFF_BIT_LEN'(BLOCK_SIZE - 1))) |=> \n      ## 2 ( \n            (bank[$past(latched_victim_set_index, 2)][$past(latched_victim_way_index, 2)].valid == 1) &&\n            (bank[$past(latched_victim_set_index, 2)][$past(latched_victim_way_index, 2)].tag == $past(mshr_entry.block_addr.tag, 2)) &&\n            (bank[$past(latched_victim_set_index, 2)][$past(latched_victim_way_index, 2)].block === $past(latched_block_pull_buffer.block, 2)) \n      );\n  endproperty\n\n  assert property (block_pull_replacement)\n      else $error(\"ASSERTIONERROR: Block not replaced properly\");\n\nendmodule\n\nmodule confirm_replacement_singlecycle (\n    input logic CLK,\n    input logic nRST,\n    input in_mem_instr mem_instr_in, \n    input logic scheduler_hit, \n    input logic [BLOCK_INDEX_BIT_LEN-1:0] set_index,\n    input logic [WAYS_LEN-1:0] hit_way_index, \n    input cache_set [NUM_SETS_PER_BANK-1:0] bank\n);\n\n  property write_replacement;\n    @(posedge CLK) disable iff (!nRST)\n    (scheduler_hit && (mem_instr_in.rw_mode == 1)) |=> ( \n        bank[$past(set_index, 1)][$past(hit_way_index, 1)].block[$past(mem_instr_in.addr.block_offset, 1)] == $past(mem_instr_in.store_value, 1)\n      );\n  endproperty\n\n  assert property (write_replacement)\n    else $error(\"ASSERTIONERROR: Word not replaced properly within block\");\n\nendmodule ","lang":"verilog"};
processSrcData(g_data);