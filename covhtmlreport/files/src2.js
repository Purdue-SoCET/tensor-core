var g_data = {"name":"./src/testbench/cache_bank_tb.sv","src":"`timescale 1ps/1ps\n`include \"cache_types_pkg.svh\";\n\nmodule RAM (\n    input logic CLK, nRST,\n    input logic [31:0] ram_addr,\n    input logic [31:0] ram_store,\n    input logic ram_REN, ram_WEN,\n    output logic [31:0] ram_load,\n    output logic ram_ready\n);\n\n    localparam cycle_delay = 5;\n\n    logic [31:0] next_ram_data [logic [31:0]];\n    logic [31:0] ram_data [logic [31:0]];\n    logic [31:0] current_addr, prev_addr;\n    logic [31:0] counter, next_counter;\n    typedef enum logic [5:0] { start, ram_read, ram_write } state_t;\n    state_t state, next_state;\n\n    assign current_addr = ram_addr;\n\n    always_ff @ (posedge CLK, negedge nRST) begin\n        if (!nRST) begin\n            counter <= 0;\n            state <= start;\n            prev_addr <= 0;\n            ram_data <= '{default: '{default: 0}}; \n        end else begin\n            counter <= next_counter;\n            state <= next_state;\n            prev_addr <= current_addr;\n            ram_data <= next_ram_data; \n        end\n    end\n\n    always_comb begin\n        next_state = state;\n\n        case (state)\n            start: begin\n                if (ram_REN) begin\n                    next_state = ram_read;\n                end\n                if (ram_WEN) begin\n                    next_state = ram_write;\n                end\n            end\n            ram_read: begin\n                if (!ram_REN) begin\n                    next_state = ram_WEN ? ram_write : start;\n                end\n                if (current_addr != prev_addr) begin\n                    next_state = ram_WEN ? ram_write : (ram_REN ? ram_read : start);\n                end\n            end\n            ram_write: begin\n                if (!ram_WEN) begin\n                    next_state = ram_REN ? ram_read : start;\n                end\n                if (current_addr != prev_addr) begin\n                    next_state = ram_WEN ? ram_write : (ram_REN ? ram_read : start);\n                end\n            end\n        endcase\n    end\n\n    always_comb begin\n        next_counter = counter;\n        ram_ready = 0;\n        ram_load = 0;\n        next_ram_data = ram_data;\n\n        case (state)\n            start: begin\n            end\n            ram_read: begin\n                if (!ram_REN || current_addr != prev_addr) begin\n                    next_counter = 0;\n                end else if (counter == cycle_delay) begin\n                    ram_ready = 1;\n                    ram_load = ram_data[current_addr];               \n                    $display(\"read from %08x: %08x\", current_addr, ram_load);     \n                end else begin\n                    next_counter = counter + 1;\n                end\n            end\n            ram_write: begin\n                if (!ram_WEN || current_addr != prev_addr) begin\n                    next_counter = 0;\n                end else if (counter == cycle_delay) begin\n                    ram_ready = 1;\n                    next_ram_data[current_addr] = ram_store;\n                    $display(\"write %08x: %08x\", current_addr, ram_store);     \n                end else begin\n                    next_counter = counter + 1;\n                end\n            end   \n        endcase\n    end\n\n\nendmodule\n\n\nmodule cache_bank_tb;\n    localparam CLK_PERIOD = 10; \n    localparam int MAX_INIT_ADDR = 256;\n\n    logic tb_clk;\n    logic tb_nrst;\n    logic [BANKS_LEN-1:0] tb_bank_id;\n    logic tb_instr_valid;\n    logic [CACHE_RW_SIZE-1:0] tb_ram_mem_data;\n    mshr_reg tb_mshr_entry;\n    in_mem_instr tb_mem_instr;\n    logic tb_ram_mem_complete;\n    logic tb_cache_bank_busy;\n    logic tb_scheduler_hit;\n    logic tb_ram_mem_REN;\n    logic tb_ram_mem_WEN;\n    logic [CACHE_RW_SIZE-1:0] tb_ram_mem_store;\n    addr_t tb_ram_mem_addr;\n    logic [31:0] tb_scheduler_data_out;\n    logic [3:0] tb_scheduler_uuid_out;\n    logic tb_scheduler_uuid_ready; \n    logic [31:0] zero_val = 32'd0;\n\n    always begin\n        tb_clk = 1'b0;\n        #(CLK_PERIOD/2);\n        tb_clk = 1'b1;\n        #(CLK_PERIOD/2);\n    end\n\n\n    initial begin \n        // u_RAM.ram_data = \n        $dumpfile(\"waveforms/cache_bank_tb.vcd\");\n        $dumpvars(0);\n    end \n    \n    RAM u_RAM (\n        .CLK(tb_clk),\n        .nRST(tb_nrst),\n        .ram_addr(tb_ram_mem_addr),\n        .ram_store(tb_ram_mem_store),\n        .ram_REN(tb_ram_mem_REN),\n        .ram_WEN (tb_ram_mem_WEN),\n        .ram_load(tb_ram_mem_data),\n        .ram_ready(tb_ram_mem_complete)\n    );\n\n    cache_bank dut (\n        .CLK(tb_clk),\n        .nRST(tb_nrst),\n        .bank_id(tb_bank_id),\n        .instr_valid(tb_instr_valid),\n        .ram_mem_data(tb_ram_mem_data),\n        .mshr_entry(tb_mshr_entry),\n        .mem_instr_in(tb_mem_instr),\n        .ram_mem_complete(tb_ram_mem_complete),\n        .cache_bank_busy(tb_cache_bank_busy),\n        .scheduler_hit(tb_scheduler_hit),\n        .ram_mem_REN(tb_ram_mem_REN),\n        .ram_mem_WEN(tb_ram_mem_WEN),\n        .ram_mem_store(tb_ram_mem_store),\n        .ram_mem_addr(tb_ram_mem_addr),\n        .scheduler_data_out(tb_scheduler_data_out),\n        .scheduler_uuid_out(tb_scheduler_uuid_out),\n        .scheduler_uuid_ready(tb_scheduler_uuid_ready)\n    );\n\n\n    bind cache_bank confirm_lru_age lru_monitor (\n        .CLK(CLK), \n        .nRST(nRST), \n        .curr_state(curr_state),\n        .lru(lru),\n        .latched_victim_set_index(latched_victim_set_index),\n        .latched_victim_way_index(latched_victim_way_index)\n    );\n\n    bind cache_bank confirm_replacement_mshr mshr_monitor (\n        .CLK(CLK), \n        .nRST(nRST), \n        .curr_state(curr_state), \n        .latched_victim_set_index(latched_victim_set_index),\n        .latched_victim_way_index(latched_victim_way_index),\n        .bank(bank), \n        .mshr_entry(mshr_entry), \n        .count_FSM(count_FSM),\n        .latched_block_pull_buffer(latched_block_pull_buffer)\n    );\n\n    bind cache_bank confirm_replacement_singlecycle singlecycle_monitor (\n        .CLK(CLK), \n        .nRST(nRST), \n        .mem_instr_in(mem_instr_in),\n        .scheduler_hit(scheduler_hit), \n        .set_index(set_index), \n        .hit_way_index(hit_way_index),\n        .bank(bank)\n    );\n\n    test PROG (\n        .tb_clk(tb_clk),\n        .tb_nrst(tb_nrst),\n        .tb_bank_id(tb_bank_id),\n        .tb_instr_valid(tb_instr_valid),\n        .tb_ram_mem_data(tb_ram_mem_data),\n        .tb_mshr_entry(tb_mshr_entry),\n        .tb_mem_instr(tb_mem_instr),\n        .tb_ram_mem_complete(tb_ram_mem_complete),\n        .tb_cache_bank_busy(tb_cache_bank_busy),\n        .tb_scheduler_hit(tb_scheduler_hit),\n        .tb_ram_mem_REN(tb_ram_mem_REN),\n        .tb_ram_mem_WEN(tb_ram_mem_WEN),\n        .tb_ram_mem_store(tb_ram_mem_store),\n        .tb_ram_mem_addr(tb_ram_mem_addr),\n        .tb_scheduler_data_out(tb_scheduler_data_out),\n        .tb_scheduler_uuid_out(tb_scheduler_uuid_out), \n        .tb_scheduler_uuid_ready(tb_scheduler_uuid_ready)\n    );\n\nendmodule\n\n// Calculated Cache Parameters:\n// -------------------------------\n// CACHE_SIZE         = 1024\n// BLOCK_SIZE         = 4\n// NUM_WAYS           = 4\n// NUM_BANKS          = 4\n// MSHR_BUFFER_LEN    = 8\n// CACHE_RW_SIZE      = 32\n\n// NUM_SETS           = 16\n// NUM_SETS_PER_BANK  = 4\n// BYTE_OFF_BIT_LEN   = 2\n// BLOCK_OFF_BIT_LEN  = 2\n// BLOCK_INDEX_BIT_LEN= 4\n// WAYS_LEN           = 2\n// BANKS_LEN          = 2\n// TAG_BIT_LEN        = 24\n\nprogram test (\n    input logic  tb_clk,\n    output logic  tb_nrst,\n    output logic [BANKS_LEN-1:0] tb_bank_id,\n    output logic  tb_instr_valid,\n    output mshr_reg  tb_mshr_entry,\n    output in_mem_instr  tb_mem_instr,\n    input logic [CACHE_RW_SIZE-1:0] tb_ram_mem_data,\n    input logic  tb_ram_mem_complete,\n    input logic  tb_cache_bank_busy,\n    input logic  tb_ram_mem_REN,\n    input logic  tb_ram_mem_WEN,\n    input logic [CACHE_RW_SIZE-1:0] tb_ram_mem_store,\n    input addr_t  tb_ram_mem_addr,\n    input logic [31:0] tb_scheduler_data_out,\n    input logic [3:0] tb_scheduler_uuid_out,\n    input logic  tb_scheduler_hit,\n    input logic  tb_scheduler_uuid_ready\n);\n\n    addr_t address;\n    mshr_reg tmp_mshr;\n    string test_id; \n    logic SingleCycle_RW_Done, MSHR_Thread_Done;\n    integer display_bit = 0; \n\n    task automatic initiate_read_write(\n        logic [TAG_BIT_LEN-1:0] tag,\n        logic [BLOCK_INDEX_BIT_LEN-1:0] index,\n        logic [BLOCK_OFF_BIT_LEN-1:0] block_offset,\n        logic [BYTE_OFF_BIT_LEN-1:0] byte_offset,\n        logic rw_mode,\n        logic [31:0] store_value\n    ); \n        tb_instr_valid = 1;\n        address = addr_t'{ tag, index, block_offset, byte_offset }; \n        tb_mem_instr  = in_mem_instr'{ address, rw_mode, store_value };\n        @(posedge tb_clk);\n        tb_instr_valid = 0;\n        log_ram_inputs(1, tb_ram_mem_complete, tb_ram_mem_addr, tb_ram_mem_store, tb_ram_mem_WEN, tb_ram_mem_REN, tb_cache_bank_busy, tb_scheduler_data_out, tb_scheduler_uuid_out, tb_scheduler_hit, tb_scheduler_uuid_ready);\n        @(posedge tb_clk);\n        @(posedge tb_clk);\n    endtask\n\n    task automatic set_mshr(\n        logic valid,\n        logic [UUID_SIZE-1:0] uuid,\n        addr_t block_addr,\n        logic [BLOCK_SIZE-1:0] write_status,\n        cache_block write_block\n    );\n        tb_mshr_entry = {valid, uuid, block_addr, write_status, write_block};\n        @(posedge tb_clk);\n    endtask\n\n    task automatic log_ram_inputs(\n        integer cycles, \n        logic _tb_ram_mem_complete,\n        logic [31:0] _tb_ram_mem_addr,\n        logic [CACHE_RW_SIZE-1:0] _tb_ram_mem_store,\n        logic _tb_ram_mem_WEN,\n        logic _tb_ram_mem_REN,\n        logic _tb_cache_bank_busy, \n        logic [31:0] _tb_scheduler_data_out,\n        logic [3:0] _tb_scheduler_uuid_out,\n        logic  _tb_scheduler_hit, \n        logic _tb_scheduler_uuid_ready\n    );\n        for (integer i = 0; i < cycles; i++) begin \n            if (display_bit) $display(\"--> ram_mem_complete: %b, ram_mem_addr: %h, ram_mem_store: %h, ram_mem_WEN: %b, ram_mem_REN: %b, tb_cache_bank_busy: %b\", _tb_ram_mem_complete, _tb_ram_mem_addr, _tb_ram_mem_store, _tb_ram_mem_WEN, _tb_ram_mem_REN, _tb_cache_bank_busy);\n            if (display_bit) $display(\"      tb_scheduler_data_out: %d, tb_scheduler_uuid_out: %h, tb_scheduler_hit: %b, _tb_scheduler_uuid_ready: %b\", _tb_scheduler_data_out, _tb_scheduler_uuid_out, _tb_scheduler_hit, _tb_scheduler_uuid_ready);\n            @(posedge tb_clk);\n        end \n    endtask\n\n    task automatic reset();\n        tb_nrst = 0;\n        tb_bank_id = '0;\n        tb_instr_valid = 0;\n        tb_mshr_entry = '0;\n        address = '0; \n        tb_mem_instr  = '0;\n        SingleCycle_RW_Done = 1'b0; \n        MSHR_Thread_Done = 1'b0;\n        @(posedge tb_clk);\n        @(posedge tb_clk);\n        tb_nrst = 1;\n        tb_bank_id = BANKS_LEN'(4'd3);\n        set_test_id(\"RESET DONE\");\n        @(posedge tb_clk);\n    endtask\n\n    task automatic fill_bank(\n        logic random_valid, \n        logic random_dirty\n    );\n        for (integer set = 0; set < NUM_SETS_PER_BANK; set++) begin\n            for (integer way = 0; way < NUM_WAYS; way++) begin\n                dut.next_bank[set][way].valid = (random_valid) ? $urandom_range(0, 1) : 1'b1;\n                dut.next_bank[set][way].dirty = (random_dirty) ? $urandom_range(0, 1) : 1'b0;\n                dut.next_bank[set][way].tag   = '1; \n                for (integer b = 0; b < BLOCK_SIZE; b++) begin\n                    dut.next_bank[set][way].block[b] = {\n                        $urandom_range(0, 8'hFF), \n                        $urandom_range(0, 8'hFF), \n                        $urandom_range(0, 8'hFF), \n                        $urandom_range(0, 8'hFF)\n                    };\n                end\n            end\n        end\n        @(posedge tb_clk);\n        @(posedge tb_clk);\n    endtask\n\n    task automatic set_test_id(\n        string test_in\n    );\n        test_id = test_in;\n        $display(test_in);\n    endtask\n\n    task stall_for_ram; \n        wait(tb_ram_mem_complete == 1);\n        @(posedge tb_clk);\n        wait(tb_ram_mem_complete == 1);\n        @(posedge tb_clk);\n        wait(tb_ram_mem_complete == 1);\n        @(posedge tb_clk);\n        wait(tb_ram_mem_complete == 1);\n        @(posedge tb_clk);\n    endtask\n\n    initial begin\n\n        set_test_id(\"-------> RESET\");\n        reset();\n\n        // Starting with empty bank!\n        set_test_id(\"-------> Trying a WRITE - MISS\");\n        initiate_read_write(\n            .tag(24'h1000), \n            .index(4'h9), \n            .block_offset(2'b00), \n            .byte_offset(2'b00), \n            .rw_mode(1'b1), \n            .store_value(32'd0)\n        );\n\n\n        set_test_id(\"-------> Filling MSHR Entry\");\n        set_mshr(\n            .valid(1'b1), \n            .uuid(4'd9),\n            .block_addr(address), \n            .write_status(BLOCK_SIZE'('0)), \n            .write_block(cache_block'('0))\n        );\n\n        set_test_id(\"-------> FSM Initiated\");\n        stall_for_ram();\n\n        set_test_id(\"-------> Clearing MSHR Entry\");\n        set_mshr(\n            .valid('0), \n            .uuid('0),\n            .block_addr('0), \n            .write_status('0), \n            .write_block('0)\n        );\n\n        set_test_id(\"-------> Trying a READ - HIT\");\n        initiate_read_write(\n            .tag(24'h1000), \n            .index(4'h9), \n            .block_offset(2'b00), \n            .byte_offset(2'b00), \n            .rw_mode(1'b0), \n            .store_value(32'd0)\n        );\n\n        set_test_id(\"-------> RANDOMIZED SIMULATION\");\n        @(posedge tb_clk);\n\n        MSHR_Thread_Done = 1; \n        SingleCycle_RW_Done = 1; \n        @(posedge tb_clk);\n\n        MSHR_Thread_Done = 0; \n        SingleCycle_RW_Done = 0; \n        @(posedge tb_clk);\n\n        \n        fork\n        begin : mshr_process\n            for (int set = 0; set < NUM_SETS; set++) begin\n                for (int way = 0; way < NUM_WAYS; way++) begin\n                    for (int blk_offset = 0; blk_offset < BLOCK_SIZE; blk_offset++) begin \n                        for (int byte_offset = 0; byte_offset < WORD_SIZE; byte_offset++) begin \n                            MSHR_Thread_Done = 0; \n\n                            set_mshr(\n                                .valid(1'b1), // 0 gets tested in top_level \n                                .uuid((set * NUM_WAYS + way)), // Helps to check request number in the waves.\n                                .block_addr(addr_t'{ \n                                    {$urandom_range(0, (1<<TAG_BIT_LEN - 1))}, \n                                    set[BLOCK_INDEX_BIT_LEN-1:0], \n                                    blk_offset[BLOCK_OFF_BIT_LEN-1:0],\n                                    byte_offset[BYTE_OFF_BIT_LEN-1:0]\n                                }), \n                                .write_status(BLOCK_SIZE'('0)), \n                                .write_block(cache_block'('0))\n                            );\n\n                            stall_for_ram();\n\n                            set_mshr(\n                                .valid('0), \n                                .uuid('0),\n                                .block_addr('0), \n                                .write_status('0), \n                                .write_block('0)\n                            );\n\n                            MSHR_Thread_Done = 1; \n                            @(posedge tb_clk);\n                        end\n                    end \n                end\n            end\n        end\n\n        begin : rw_process\n            for (int set = 0; set < NUM_SETS; set++) begin\n                for (int way = 0; way < NUM_WAYS; way++) begin\n                    for (int blk_offset = 0; blk_offset < BLOCK_SIZE; blk_offset++) begin \n                        for (int byte_offset = 0; byte_offset < WORD_SIZE; byte_offset++) begin \n                            SingleCycle_RW_Done = 0; \n\n                            initiate_read_write(\n                                .tag($urandom_range(0, (1<<TAG_BIT_LEN - 1))), \n                                .index(set[BLOCK_INDEX_BIT_LEN-1:0]), \n                                .block_offset(blk_offset[BLOCK_OFF_BIT_LEN-1:0]), \n                                .byte_offset(byte_offset[BYTE_OFF_BIT_LEN-1:0]), \n                                .rw_mode(1'b0), \n                                .store_value($urandom_range(0, (1<<CACHE_RW_SIZE - 1)))\n                            );\n\n                            SingleCycle_RW_Done = 1; \n                            @(posedge tb_clk);\n                        end\n                    end\n                end\n            end\n        end\n        join\n\n\n        MSHR_Thread_Done = 0; \n        SingleCycle_RW_Done = 0; \n        @(posedge tb_clk);\n\n        set_test_id(\"-------> FINISH\");\n\n        $finish;\n    end\nendprogram","lang":"verilog"};
processSrcData(g_data);