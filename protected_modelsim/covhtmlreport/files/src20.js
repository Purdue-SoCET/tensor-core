var g_data = {"name":"./src/row_open.sv","src":"//Implementing the open-row policy\n`timescale 1ps/1ps\n`include \"row_open_if.vh\"\n\nmodule row_open (\n    input logic CLK,\n    input logic nRST,\n    row_open_if.dut pol_if\n);\n    import dram_pkg::*;\n    parameter int DEPTH = 16;\n    typedef struct packed {\n        logic [1:0] bank_group;\n        logic [1:0] bank;\n    } addr_t;\n\n    typedef struct packed {\n        logic valid;\n        logic [ROW_BITS-1:0] row;\n    } reg_t;\n\n    reg_t [DEPTH - 1:0] reg_f, nreg_f;\n    logic [1:0] nrow_stat;\n    logic [8:0] nrow_conflict;\n    addr_t ptr;\n\n    logic [$clog2(DEPTH)-1:0] row_open_cnt, nrow_open_cnt;\n\n    assign ptr = addr_t'({pol_if.bank_group, pol_if.bank});\n\n    always_ff @(posedge CLK, negedge nRST) begin\n        if (!nRST) begin\n            reg_f <= 0;\n            row_open_cnt <= 0;\n            // pol_if.row_stat <= 0;\n            // pol_if.row_conflict <= 0;\n            \n        end else begin\n            reg_f <= nreg_f;\n            row_open_cnt <= nrow_open_cnt;\n            // pol_if.row_stat <= nrow_stat;\n            // pol_if.row_conflict <= nrow_conflict;\n        end\n    end\n\n    assign pol_if.row_stat = nrow_stat;\n    assign pol_if.row_conflict = nrow_conflict;\n    assign pol_if.all_row_closed = row_open_cnt == 0;\n    always_comb begin\n        nreg_f = reg_f;\n        nrow_stat = 0;\n        // nrow_conflict = pol_if.row_conflict;\n        nrow_conflict = 0;\n        nrow_open_cnt = row_open_cnt;\n\n        //Comment out for check the refresh state\n        if (pol_if.refresh) begin\n            nreg_f = 0;\n            nrow_open_cnt = 0;\n        end \n        else begin\n            if (pol_if.req_en) begin\n                if (reg_f[ptr].valid && reg_f[ptr].row == pol_if.row) begin\n                    nrow_stat = 2'b01; //HIT\n                    if (pol_if.row_resolve) begin\n                        nreg_f[ptr].valid = 0;\n                        nrow_open_cnt = row_open_cnt - 1;\n                    end\n                end else if (reg_f[ptr].valid) begin\n                    nrow_stat = 2'b11; //CONFLICT\n                    nrow_conflict = reg_f[ptr].row;\n                    if (pol_if.row_resolve) begin\n                        nreg_f[ptr].valid = 0;\n                        nrow_open_cnt = row_open_cnt -1;\n                        nrow_stat = 2'b0; //IDLE\n                    end\n                end\n                else begin\n                    nrow_stat = 2'b10; //MISS\n                    if (pol_if.tACT_done) begin\n                        nreg_f[ptr].valid = 1'b1;\n                        nreg_f[ptr].row = pol_if.row;\n                        nrow_open_cnt = row_open_cnt + 1;\n                    end\n                end\n            end\n        end\n    end\n\n    \n\nendmodule","lang":"verilog"};
processSrcData(g_data);