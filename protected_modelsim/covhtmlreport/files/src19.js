var g_data = {"name":"./src/address_mapper.sv","src":"`include \"dram_pkg.vh\"\n`include \"address_mapper_if.vh\"\n\nmodule addr_mapper #(\n    // parameter RANK_BITS = 1,\n    //           BANK_GROUP_BITS = 2,\n    //           BANK_BITS = 2,\n    //           ROW_BITS = 15,\n    //           COLUMN_BITS = 10,\n    //           OFFSET_BITS = 2,\n    //           IGNORE_BITS = 1,\n    //           CONFIGS = 4            // (possible values x4, x8, x16)\n) (\n    // input  logic [31:0] address,\n    // output logic [RANK_BITS - 1:0] rank,\n    // output logic [BANK_GROUP_BITS - 1:0] BG,\n    // output logic [BANK_BITS - 1:0] bank,\n    // output logic [ROW_BITS - 1:0] row,\n    // output logic [COLUMN_BITS - 1:0] col,\n    // output logic [OFFSET_BITS - 1:0] offset,\n\n    address_mapper_if.addr_mapper amif\n);\n    import dram_pkg::*;\n    // ignore bits for discarding extra address bits after rank bits and before row bits\n    // logic [IGNORE_BITS - 1:0] ignore;\n\n\n    always_comb begin \n        {amif.rank, amif.row, amif.bank, amif.BG[1], amif.col[9:3], amif.BG[0], amif.col[2:0], amif.offset} = 0;\n        if (amif.configs == x4 || amif.configs == x8) begin\n            //TODO: The address mapper is ok we we need to make somechange \n            // {amif.rank, amif.row, amif.bank, amif.BG[1], amif.col[9:3], amif.BG[0], amif.col[2:0], amif.offset} = amif.address;\n            //The offset of the burst can use to mux to give back to data transfer, but writing, we want to ensure that it start with 0 first\n            {amif.rank, amif.row, amif.bank, amif.BG[1], amif.col[9:3], amif.BG[0], amif.col[2:0], amif.offset} = {amif.address[30:6],3'b0,amif.address[1:0]};\n        end\n        // x16 has only 1 BG bit (2 BGs) \n        else if (amif.configs == x16) begin\n            {amif.rank, amif.row, amif.bank, amif.BG, amif.col, amif.offset} = amif.address;\n        end\n    end\n    \nendmodule\n","lang":"verilog"};
processSrcData(g_data);