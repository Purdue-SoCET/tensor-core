var g_data = {"name":"./src/timing_signal.sv","src":"`include \"dram_pkg.vh\"\n`include \"timing_signal_if.vh\"\n`include \"command_FSM_if.vh\"\n\nmodule timing_signal (\n    input logic CLK, nRST,\n    timing_signal_if.timing_ctrl timif,\n    command_FSM_if.timing_ctrl cfsmif\n);\n    import dram_pkg::*;\n    \n    \n    \n    // time counter signals\n    parameter N = 10;\n    logic [N-1:0] time_load, time_count;\n    logic time_counter_en, time_count_done;\n    logic clear;\n\n    always_comb begin\n        timif.tACT_done = 1'b0;\n        timif.tWR_done = 1'b0;\n        timif.tRD_done = 1'b0;\n        timif.tPRE_done = 1'b0;\n        timif.tREF_done = 1'b0;\n        \n        time_counter_en = 1'b0;\n        time_load = '0;\n\n        timif.wr_en = 1'b0;\n        timif.rd_en = 1'b0;\n        timif.clear = 1'b0;\n        clear = 1'b0;\n\n        case (cfsmif.cmd_state)\n            ACTIVATE : begin\n                time_counter_en = 1'b1;\n                time_load = tRAS;\n                \n                // if (timif.rf_req == 1'b1) begin         // ACT -> PRE time for refresh requests\n                //     time_load = tRAS;\n                // end\n\n                // else begin                              // ACT -> READ/WRITE time\n                //     time_load = tRCD - tAL + 1;             // tAL = 0 if AL command not set. Only tRCD is a safer option\n                // end\n\n                // TODO for consecutive commands\n                // tRRD for consecutive activates\n                // tFAW for 4 consecutive activates with tRRD_s? (Need to check if only tRRD_s or tRRD_l as well)\n                // tRC for ACT -> ACT / REF commands to same bank\n                \n            end\n\n            ACTIVATING : begin\n\n                if ((time_count_done == tRAS - 12 + 1) && (!timif.rf_req)) begin\n                    clear = 1;\n                    timif.tACT_done = 1'b1;\n                end \n\n                if (time_count_done == 1'b1) begin\n                    timif.tACT_done = 1'b1;\n                end\n            end\n\n            READ : begin\n                time_counter_en = 1'b1;\n                //TODO rd_en turn off too early, we havent dont receive data\n                time_load = tRL + tBURST + 1;\n\n                // TODO for consecutive reads\n                // tCCD_S = diff BG\n                // tCCD_L = same BG\n            end\n\n            READING : begin\n                if (time_count <= tBURST) begin\n                    timif.rd_en = 1'b1;\n                end\n\n                if (time_count_done == 1'b1) begin\n                    timif.tRD_done = 1'b1;\n                    timif.rd_en = 1'b0;\n                    timif.clear = 1'b1; //For data transfer ignore it\n                end\n\n                \n            end\n\n            WRITE : begin\n                time_counter_en = 1'b1;\n                // time_load = tWL + tBURST;\n                time_load = tWL + tBURST + tWR; //tWR for the write time re\n                // TODO for Write -> to precharge case:\n                // tCCD_S = diff BG\n                // tCCD_L = same BG\n            end\n\n            WRITING : begin\n                if (time_count <= tBURST + tWR + 2) begin\n                    timif.wr_en = 1'b1;\n                end \n                if (time_count <= tWR) begin\n                    timif.wr_en = 1'b0;\n                end\n	                \n                if (time_count_done == 1'b1) begin\n	                timif.tWR_done = 1'b1;\n                    timif.wr_en = 1'b0;\n                    timif.clear = 1'b0;\n                end\n            end\n\n            PRECHARGE : begin\n                time_counter_en = 1'b1;\n                time_load = tRP;\n            end\n\n            PRECHARGING : begin\n                if (time_count_done == 1'b1) begin\n                    timif.tPRE_done = 1'b1;\n                end\n            end\n\n            REFRESH : begin\n                time_counter_en = 1'b1;\n                time_load = tRFC;\n            end\n\n            REFRESHING : begin\n                if (time_count_done == 1'b1) begin\n                    timif.tREF_done = 1'b1;\n                end\n            end\n\n        endcase\n    end\n\n    //////////// REFRESH ////////////\n    logic [N-1:0] refresh_limit, next_refresh_limit;\n    logic [N-1:0] refresh_count, next_refresh_count;\n\n    always_ff @(posedge CLK, negedge nRST) begin : REFRESH_REG_LOGIC\n        if (~nRST) begin\n            refresh_count <= '0;\n            refresh_limit <= tREFI;\n        end\n\n        else begin\n            refresh_count <= next_refresh_count;\n            refresh_limit <= next_refresh_limit;\n        end\n    end\n\n    always_comb begin : REFRESH_COMB_LOGIC\n        timif.rf_req = 1'b0;\n\n        // REFRESH command is required every tREFI on average.\n        // If refresh counter is over the tREFI limit, subtract the\n        // additional time from tREFI for next refresh limit.\n        \n        next_refresh_limit = refresh_limit;\n\n        if (cfsmif.cmd_state == REFRESH || cfsmif.cmd_state == REFRESHING) begin\n            if (refresh_count < tREFI) begin\n                next_refresh_limit = tREFI;\n            end\n        end\n        else begin\n            if (refresh_count > tREFI) begin\n                next_refresh_limit = tREFI - (refresh_count - tREFI);\n            end\n        end\n\n        \n        // Set the refresh counter to 0 in the REFRESH state.\n        // Otherwise, the refresh counter is always incrementing.\n\n        next_refresh_count = (!timif.init_done) ? refresh_count : refresh_count + 1;\n        if (cfsmif.cmd_state == REFRESH || cfsmif.cmd_state == REFRESHING) begin\n            next_refresh_count = '0;\n        end\n\n        // Maximum time between refreshes is 9 * tREFI.\n        // if (refresh_count == MAX_tREFRESH_LIMIT - (tWL + tRP) || refresh_count == tREFRESH_LIMIT - (tRL + tRP)) begin\n        //     timif.rf_req = 1'b1;\n        // end\n        // Set the refresh request high when refresh count over or equal the refresh limit.\n        if ((refresh_count >= refresh_limit) && (cfsmif.cmd_state != REFRESH)) begin\n            timif.rf_req = 1'b1;\n        end\n    end \n\n    flex_counter #(.N(N)) time_counter (.CLK(CLK), .nRST(nRST), .enable(time_counter_en),\n                                        .count_load(time_load), .clear(clear), .count(time_count), \n                                        .count_done(time_count_done));\n\n    \n\n\nendmodule","lang":"verilog"};
processSrcData(g_data);