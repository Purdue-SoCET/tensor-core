var g_data = {"name":"./src/control_unit.sv","src":"`timescale 1ns/1ps\n\n//include modules file\n`include \"control_unit_if.vh\"\n`include \"command_FSM_if.vh\"\n`include \"init_state_if.vh\"\n`include \"address_mapper_if.vh\"\n`include \"row_open_if.vh\"\n`include \"timing_signal_if.vh\"\n\n\nmodule control_unit(\n    input logic CLK,\n    input logic nRST,\n    control_unit_if.arb mytop,\n    control_unit_if.dram_sig mysig\n\n);\n    import dram_pkg::*;\n\n    logic init_done_l;\n\n\n    always_ff @(posedge CLK, negedge nRST) begin\n        if(!nRST) begin\n            init_done_l <= 0;\n        end else begin\n            init_done_l <= myinit.init_done;\n\n        end\n    end\n\n    command_FSM_if mycmd();\n    init_state_if myinit();\n    address_mapper_if myaddr();\n    row_open_if myrow();\n    timing_signal_if mytime();\n\n    addr_mapper u0 (.amif(myaddr));\n    row_open u1(.CLK(CLK), .nRST(nRST), .pol_if(myrow));\n    init_state u2(.CLK(CLK), .nRST(nRST), .it(myinit));\n    command_FSM u3 (.CLK(CLK), .nRST(nRST), .mycmd(mycmd));\n    timing_signal u4 (.CLK(CLK), .nRST(nRST), .timif(mytime), .cfsmif(mycmd));\n\n    //Interface for command_FSM and timing module\n    assign mycmd.tACT_done = mytime.tACT_done;\n    assign mycmd.tWR_done =  mytime.tWR_done;\n    assign mycmd.tPRE_done = mytime.tPRE_done;\n    assign mycmd.rf_req =    mytime.rf_req;\n    assign mycmd.tRD_done =  mytime.tRD_done;\n    assign mycmd.tREF_done = mytime.tREF_done;\n    assign myrow.tACT_done = mytime.tACT_done;\n    \n\n    //Request interface between memory arbiter and command FSM\n    assign mycmd.dREN = mytop.dREN;\n    assign mycmd.dWEN = mytop.dWEN;\n    assign mytop.ram_wait = mycmd.ram_wait;\n\n    //Interface between init and command FSM\n    assign myinit.init = mycmd.init_req;\n    assign mycmd.init_done = myinit.init_done;\n    assign mytime.init_done =  myinit.init_done;\n\n    //Address mapper\n    assign myaddr.address = mytop.ram_addr;\n    assign myaddr.configs = x8;\n\n    //Row policy connection\n    assign myrow.bank_group = myaddr.BG;\n    assign myrow.bank = myaddr.bank;\n    assign myrow.row = myaddr.row;\n    assign myrow.req_en = mytop.dWEN || mytop.dREN;\n    assign myrow.row_resolve = mycmd.row_resolve;\n    assign myrow.refresh = mytime.tREF_done;\n    assign mycmd.row_stat = myrow.row_stat;\n    assign mycmd.all_row_closed = myrow.all_row_closed;\n\n    //Interface between control unit and data transfer\n    assign mytop.wr_en = mytime.wr_en;\n    assign mytop.rd_en = mytime.rd_en;\n    assign mytop.clear = mytime.clear;\n    assign mytop.offset = myaddr.offset;\n\n    \n    //Logic for state, nstate with mux\n    always_comb begin\n        if (!init_done_l) begin\n            mysig.state = myinit.init_state;\n            mysig.nstate = myinit.ninit_state;\n        end else begin\n            mysig.state = mycmd.cmd_state;\n            mysig.nstate = mycmd.ncmd_state;\n        end\n    end\n\n    //Logic for handling the row conflict\n    always_comb begin\n        mysig.rank = myaddr.rank;\n        mysig.BG   = myaddr.BG;\n        mysig.bank = myaddr.bank;\n        mysig.col  = {myaddr.col, myaddr.offset};\n        mysig.rf_req = mytime.rf_req;\n        //If we have the row conflicton\n        if (myrow.row_stat == 2'b11) begin\n            mysig.row = myrow.row_conflict; \n        end else begin\n            mysig.row = myaddr.row;\n        end\n    end\n\n\n\n\n\nendmodule","lang":"verilog"};
processSrcData(g_data);