var g_data = {"name":"./tb/dram_top_tb.sv","src":"`include \"dram_pkg.vh\"\n`include \"scheduler_buffer_if.vh\"\n`include \"data_transfer_if.vh\"\n`include \"control_unit_if.vh\"\n`include \"signal_gen_if.vh\"\n`include \"arch_defines.v\"\n`include \"dimm.vh\"\n`timescale 1 ns / 1 ps\n\n\n//Welcome to the mess, here is just a bunch of code that trying to verify DDR4!\n// 1. Test the power up state\n// 2. Test the refresh cycle \n// 3. Test row miss write row hit read\n// 4. Test row hit write row hit read\n// 5. Test the refresh and row miss read\n// 6. Test 3 consectutive  row miss write\n// 7. Test row conflict write row hit read\n// 8. Test row conflcit read (the old address that cause write)\n\nmodule dram_top_tb;\n    parameter PERIOD = 1.5;\n    parameter tCK = 1.5;\n    import dram_pkg::*;\n    // import arch_package::*;\n    import proj_package::*;\n\n    //parameter from dram_command_if.vh\n    parameter int MAX_DQ_BITS         = 16;\n    parameter int MAX_DQS_BITS        = 2;\n    parameter int MAX_DM_BITS         = 2;\n    parameter CONFIGURED_DQ_BITS     = 8;\n    parameter CONFIGURED_DQS_BITS     = (16 == CONFIGURED_DQ_BITS) ? 2 : 1;\n    parameter CONFIGURED_DM_BITS     = (16 == CONFIGURED_DQ_BITS) ? 2 : 1;\n    parameter CONFIGURED_RANKS = 1;\n    \n    // signals\n    logic CLK = 1, nRST;\n    logic CLKx2=0;\n    reg model_enable_val;\n    string task_name;\n\n    //Instantiate the the iDDR4_1 version\n    // addr_x4_t ramaddr_phy, ramaddr_phy_ft, ramstore_phy, ramstore_phy_ft;\n    reg clk_val, clk_enb;\n    // DQ transmit\n    reg[MAX_DQ_BITS-1:0] dq_out;\n    reg[MAX_DQS_BITS-1:0] dqs_out;\n    reg[MAX_DM_BITS-1:0] dm_out;\n    logic [31:0] data_store1;\n    logic [31:0] data_store2;\n    logic [31:0] data_store3;\n    logic [31:0] data_store4;\n    logic DM_debug;\n    assign model_enable = model_enable_val;\n\n    //Signal flag to choose write or read\n    reg dq_en;\n    reg dqs_en;\n    logic don_t_write;\n    logic [31:0] prev_addr; \n\n    //Cache signals\n    logic cache_write;\n    logic cache_read;\n    logic [ROW_BITS-1:0] cache_addr;\n    logic [2:0] cache_offset;\n    logic [63:0] cache_store;\n    logic [63:0] cache_load;\n    \n\n    always begin\n        CLK = 1'b0;\n        #(PERIOD / 2.0);\n        CLK = 1'b1;\n        #(PERIOD / 2.0);\n    end\n\n    always begin\n        CLKx2 = 1'b1;\n        #(PERIOD / 4.0);\n        CLKx2 = 1'b0;\n        #(PERIOD / 4.0);\n    end\n\n    // ddr4_module_if iDDR4_1();\n    control_unit_if dc_if();\n    signal_gen_if sig_if();\n    scheduler_buffer_if sch_if();\n    data_transfer_if dt_if();\n    \n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_1();\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_2();\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_3();\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_4();\n\n\n    dram_top DUT (.CLK(CLK), .nRST(nRST), .myctrl(dc_if), .myctrl_sig(dc_if), .mysig(sig_if));\n    scheduler_buffer SCH_BUFF (.CLK(CLK), .nRST(nRST), .mysche(sch_if));\n    data_transfer DT (.CLK(CLK), .CLKx2(CLKx2),.nRST(nRST), .mydata(dt_if));\n\n    //Instantiate cache for verify\n    sw_cache CACHE (.CLKx2(CLKx2), .nRST(nRST), .wr_en(cache_write), .rd_en(cache_read), .row_addr(cache_addr), .offset(cache_offset), .dmemstore(cache_store), .dmemload(cache_load));\n\n    //Scheduler interface with the \n    always_comb begin\n      dc_if.dREN = (!dc_if.ram_wait) ? 0 : sch_if.ramREN_curr;\n      dc_if.dWEN = (!dc_if.ram_wait) ? 0 : sch_if.ramWEN_curr;\n      dc_if.ram_addr = sch_if.ramaddr_rq;\n      \n    //   dc_if.ramWEN_ftrt = sch_if.ramWEN_ftrt;\n      sch_if.request_done = !dc_if.ram_wait;\n    \n\n      //Interface between scheduler buffer and the data_transfer\n      dt_if.wr_en = dc_if.wr_en;\n      dt_if.rd_en = dc_if.rd_en;\n\n    //  Comment this out for testing with class sche_clas\n    //   dt_if.memstore = sch_if.ramstore_rq;\n    end\n\n    always @(posedge clk_val && clk_enb) begin\n        clk_val <= #(tCK/2) 1'b0;\n        clk_val <= #(tCK) 1'b1;\n        iDDR4_1.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_1.CK[1] <= #(tCK) 1'b1;\n        iDDR4_1.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_1.CK[0] <= #(tCK) 1'b0;  \n\n        iDDR4_2.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_2.CK[1] <= #(tCK) 1'b1;\n        iDDR4_2.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_2.CK[0] <= #(tCK) 1'b0;\n\n        iDDR4_3.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_3.CK[1] <= #(tCK) 1'b1;\n        iDDR4_3.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_3.CK[0] <= #(tCK) 1'b0;\n\n        iDDR4_4.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_4.CK[1] <= #(tCK) 1'b1;\n        iDDR4_4.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_4.CK[0] <= #(tCK) 1'b0;\n\n\n        iDDR4_1.ACT_n     <= sig_if.ACT_n;\n        iDDR4_1.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_1.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_1.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_1.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_1.PARITY    <= sig_if.PARITY;\n        iDDR4_1.RESET_n   <= sig_if.RESET_n;\n        iDDR4_1.TEN       <= sig_if.TEN;\n        iDDR4_1.CS_n      <= sig_if.CS_n;\n        iDDR4_1.CKE       <= sig_if.CKE;\n        iDDR4_1.ODT       <= sig_if.ODT;\n        iDDR4_1.C         <= sig_if.C;\n        iDDR4_1.BG        <= sig_if.BG;\n        iDDR4_1.BA        <= sig_if.BA;\n        iDDR4_1.ADDR      <= sig_if.ADDR;\n        iDDR4_1.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_1.ZQ        <= sig_if.ZQ;\n        iDDR4_1.PWR       <= sig_if.PWR;\n        iDDR4_1.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_1.VREF_DQ   <= sig_if.VREF_DQ;\n\n        //DRAM 2\n        iDDR4_2.ACT_n     <= sig_if.ACT_n;\n        iDDR4_2.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_2.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_2.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_2.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_2.PARITY    <= sig_if.PARITY;\n        iDDR4_2.RESET_n   <= sig_if.RESET_n;\n        iDDR4_2.TEN       <= sig_if.TEN;\n        iDDR4_2.CS_n      <= sig_if.CS_n;\n        iDDR4_2.CKE       <= sig_if.CKE;\n        iDDR4_2.ODT       <= sig_if.ODT;\n        iDDR4_2.C         <= sig_if.C;\n        iDDR4_2.BG        <= sig_if.BG;\n        iDDR4_2.BA        <= sig_if.BA;\n        iDDR4_2.ADDR      <= sig_if.ADDR;\n        iDDR4_2.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_2.ZQ        <= sig_if.ZQ;\n        iDDR4_2.PWR       <= sig_if.PWR;\n        iDDR4_2.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_2.VREF_DQ   <= sig_if.VREF_DQ;\n\n        //DRAM 3\n        iDDR4_3.ACT_n     <= sig_if.ACT_n;\n        iDDR4_3.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_3.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_3.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_3.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_3.PARITY    <= sig_if.PARITY;\n        iDDR4_3.RESET_n   <= sig_if.RESET_n;\n        iDDR4_3.TEN       <= sig_if.TEN;\n        iDDR4_3.CS_n      <= sig_if.CS_n;\n        iDDR4_3.CKE       <= sig_if.CKE;\n        iDDR4_3.ODT       <= sig_if.ODT;\n        iDDR4_3.C         <= sig_if.C;\n        iDDR4_3.BG        <= sig_if.BG;\n        iDDR4_3.BA        <= sig_if.BA;\n        iDDR4_3.ADDR      <= sig_if.ADDR;\n        iDDR4_3.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_3.ZQ        <= sig_if.ZQ;\n        iDDR4_3.PWR       <= sig_if.PWR;\n        iDDR4_3.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_3.VREF_DQ   <= sig_if.VREF_DQ;\n\n        //DRAM 4\n        iDDR4_4.ACT_n     <= sig_if.ACT_n;\n        iDDR4_4.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_4.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_4.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_4.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_4.PARITY    <= sig_if.PARITY;\n        iDDR4_4.RESET_n   <= sig_if.RESET_n;\n        iDDR4_4.TEN       <= sig_if.TEN;\n        iDDR4_4.CS_n      <= sig_if.CS_n;\n        iDDR4_4.CKE       <= sig_if.CKE;\n        iDDR4_4.ODT       <= sig_if.ODT;\n        iDDR4_4.C         <= sig_if.C;\n        iDDR4_4.BG        <= sig_if.BG;\n        iDDR4_4.BA        <= sig_if.BA;\n        iDDR4_4.ADDR      <= sig_if.ADDR;\n        iDDR4_4.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_4.ZQ        <= sig_if.ZQ;\n        iDDR4_4.PWR       <= sig_if.PWR;\n        iDDR4_4.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_4.VREF_DQ   <= sig_if.VREF_DQ;\n    end\n\n    // Component instantiation\n    //Only use 4 chips only\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u0_r0(.model_enable(model_enable), .iDDR4(iDDR4_1));\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u1_r0(.model_enable(model_enable), .iDDR4(iDDR4_2));\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u2_r0(.model_enable(model_enable), .iDDR4(iDDR4_3));\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u3_r0(.model_enable(model_enable), .iDDR4(iDDR4_4));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u4_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u4_r0));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u5_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u5_r0));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u6_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u6_r0));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u7_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u7_r0));\n\n    //Interface between iDDR4 and data transfer example\n    assign {\n        iDDR4_1.DQ,\n        iDDR4_2.DQ,\n        iDDR4_3.DQ,\n        iDDR4_4.DQ\n    } = dq_en ? {dt_if.DQ} : {32{1'bz}};\n\n\n    assign {\n        iDDR4_1.DQS_t,\n        iDDR4_2.DQS_t,\n        iDDR4_3.DQS_t,\n        iDDR4_4.DQS_t\n    } = dq_en ? {dt_if.DQS_t,\n                 dt_if.DQS_t,\n                 dt_if.DQS_t,\n                 dt_if.DQS_t  \n                 } : 4'bzz;\n\n    assign {\n        iDDR4_1.DQS_c,\n        iDDR4_2.DQS_c,\n        iDDR4_3.DQS_c,\n        iDDR4_4.DQS_c\n    } = dq_en ? {\n        dt_if.DQS_c,\n        dt_if.DQS_c,\n        dt_if.DQS_c,\n        dt_if.DQS_c\n        } : 4'bzz;\n\n    assign {\n        iDDR4_1.DM_n,\n        iDDR4_2.DM_n,\n        iDDR4_3.DM_n,\n        iDDR4_4.DM_n\n    } = dq_en ? {\n        dt_if.DM_n,\n        dt_if.DM_n,\n        dt_if.DM_n,\n        dt_if.DM_n\n    } : 4'bzz;\n\n\n    assign dt_if.DQ = ~dq_en ? {\n        iDDR4_1.DQ,\n        iDDR4_2.DQ,\n        iDDR4_3.DQ,\n        iDDR4_4.DQ\n    } : {32{1'bz}};\n\n\n    assign dt_if.DQS_t = ~dq_en ? iDDR4_1.DQS_t : 1'bz;\n    assign dt_if.DQS_c = ~dq_en ? iDDR4_1.DQS_c: 1'bz;\n    assign dt_if.DM_n = ~dq_en ? iDDR4_1.DM_n: 1'bz;\n    assign dt_if.COL_choice = dc_if.offset; //CHANGE\n\n    always_ff @(posedge CLK) begin\n        if (!nRST) begin\n            prev_addr <= 0;\n        end else begin\n            if (!don_t_write) begin\n                prev_addr <= sch.creating_addr;\n            end\n\n        end\n    end\n\n    //Creating class for the transaction\n    class sche_trans;\n        virtual scheduler_buffer_if vif;\n        localparam logic [14:0] ROW_HIT    = 15'h1234;   // \"open\" row for the hit/conflict cases\n        localparam logic [14:0] ROW_OTHER  = 15'h2ACE;   // different row -> conflict\n        rand logic [RANK_BITS - 1:0] rank;\n        rand logic [BANK_GROUP_BITS - 1:0] BG;\n        rand logic [BANK_BITS - 1:0] bank;\n        rand logic [ROW_BITS - 1:0] row;\n        rand logic [COLUMN_BITS - 1:0] col;\n        rand logic [OFFSET_BITS - 1:0] offset;\n        logic [31:0] creating_addr;\n        //1. Creating covergroup\n        covergroup sch_group @(posedge CLK);\n            //2.Creating coverpoint\n            sch_point : coverpoint {vif.dREN, vif.dWEN} {\n                bins s00 = {2'b00};\n                bins s10 = {2'b10};\n                bins s01 = {2'b01};\n            }\n        endgroup        \n\n        //3. Creating the constraint\n        constraint req_cons {\n            {vif.dREN, vif.dWEN} != 2'b11;\n        }\n\n        constraint addr_rank {\n            rank == 1'b0;\n            row != '1;\n            offset == 0;\n            col[2:0] == 0; //8-byte align\n        }\n\n        function new (virtual scheduler_buffer_if vif);\n            this.vif = vif;\n            sch_group = new();\n        endfunction\n\n        function create_addr (string testcase, input logic[31:0] prev_addr);\n            //If you want to add row conflict\n            if (testcase == \"row conflict\") begin\n                creating_addr = prev_addr;\n                creating_addr[30:17] = '1;\n            end else if (testcase == \"row hit\") begin\n                creating_addr = prev_addr;\n            end else begin\n                creating_addr = {rank, row, bank, BG[1], col[9:3], BG[0], col[2:0], offset};\n            end\n        endfunction\n\n    endclass\n\n    class creating_dt;\n        rand logic [31:0] data_store;\n        function new ();\n\n        endfunction\n        function display;\n            $display (\"data_store %0x\", data_store);\n        endfunction\n    endclass\n\n    creating_dt dt_class;   \n    sche_trans sch;\n\n    task writing_1(input logic [31:0] addr, input creating_dt dt_class);\n        begin\n        // task_name = \"Write 1\";\n        \n        // add_request(.addr({16'hAAAA, 8'hAA, 8'b000_000_00}), .write(1'b1), .data(32'hAAAA_AAAA));\n        add_request(.addr(addr), .write(1'b1), .data(32'hAAAA_AAAA));\n        while (!dt_if.wr_en) begin\n            @(posedge CLK);\n        end\n        for (int i = 0; i < 9; i++) begin\n            dt_class.randomize();\n            // dt_class.display();\n            dt_if.memstore = dt_class.data_store;\n            // $display (\"Here is  i : %0x, and memstore: %0x\", i, dt_class.data_store);\n            if (i != 0) begin\n                cache_addr = addr[30:16];\n                cache_write = 1'b1;\n                cache_store = dt_class.data_store;\n                cache_offset = i - 1;\n            end\n            @(posedge CLKx2);\n        end\n        dt_if.clear = 1'b1;\n        cache_write = 1'b0;\n        @(posedge CLK);\n        dt_if.clear = 1'b0;\n        end\n    endtask\n\n    task writing_read_row_hit(input creating_dt dt_class);\n        task_name = \"Writing_Cycle\";\n        //Case 2 check the writing cycle\n        // add_request(.addr({16'hAAAA, 8'hAA, 8'b000_000_00}), .write(1'b1), .data(32'hAAAA_AAAA));\n        //Case checking the writing burst\n        //Creating new addr\n        sch.randomize();\n        sch.create_addr(\"row miss\", prev_addr);\n        writing_1(sch.creating_addr, dt_class);\n        repeat (50) @(posedge CLK);\n\n        \n        task_name = \"Reading_Cycle\";\n        dq_en = 1'b0;\n        // //Case 3 check the reading cycle\n        // add_request(.addr({16'hAAAA, 8'hAA, 8'b000_000_00}), .write(1'b0), .data(32'hAAAA_AAAA));\n        add_request(.addr(sch.creating_addr), .write(1'b0), .data(32'hAAAA_AAAA));\n        repeat (50) @(posedge CLK);\n    endtask\n\n    task read_with_verify (\n        input logic [31:0] addr,\n        input sche_trans sch\n    );\n        dq_en = 0;\n        add_request(.addr(addr), .write(1'b0), .data(32'hAAAA_AAAA));\n        while (dc_if.ram_wait) begin\n            cache_read = 1;\n            if (dt_if.edge_flag) begin\n                cache_addr = sch.creating_addr[30:16];\n                cache_offset = cache_offset + 1;\n                @(posedge CLKx2);\n            end else begin\n                cache_offset = 0;\n                @(posedge CLKx2);\n            end\n        end\n        dq_en = 1;\n        cache_read = 1;\n        dt_if.clear = 0;\n        repeat(10) @(posedge CLK);\n    endtask\n\n    \n\n    //Creating the assert to check the failed case\n    // property wr_verify;\n    //     @(posedge CLK) disable iff (!nRST)\n    //     dt_if.rd_en && (dt_if.edge_flag) |-> (cache_load == dt_if.memload);\n    // endproperty\n\n    // assert property (wr_verify)\n    // else \n    //     $error(\"Addr: %0x, offset: %0x, cache load: %0x, dt_memload: %0x\", sch.creating_addr[30:16], cache_offset, cache_load, dt_if.memload);\n\n    initial begin\n      iDDR4_1.CK = 2'b01;\n      clk_enb = 1'b1;\n      clk_val = 1'b1;  \n      model_enable_val = 1;\n      dq_en = 1'b1;\n      don_t_write = 0;\n      \n      //Cache\n      cache_addr = 0;\n      cache_write = 0;\n      cache_read = 0;\n      cache_offset = 0;\n      cache_store = 0;\n      \n      \n      dt_class = new();\n      sch = new(sch_if);\n      nRST = 1'b0;\n      @(posedge CLK);\n      @(posedge CLK);\n      nRST = 1'b1;\n\n      \n      task_name = \"Power_up\";\n      #((tRESET + tPWUP + tRESETCKE + tPDc + tXPR + tDLLKc + tMOD * 7 + tZQinitc) * PERIOD);\n      repeat (25) @(posedge CLK);\n\n    //   //Case 1 check the refresh case no interrept\n    //   task_name = \"Refresh\";\n    //   repeat (100) @(posedge CLK);\n    \n    task_name = \"Writing_Cycle\";\n    //Case 2 check the writing cycle\n    //Case checking the writing burst\n    //Creating new addr\n    sch.randomize();\n    sch.create_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    repeat (50) @(posedge CLK);\n\n    \n    task_name = \"Reading_Cycle\";\n    dq_en = 1'b0;\n    //Case 3 check the reading cycle\n    read_with_verify(sch.creating_addr, sch);\n    \n    \n    //checking the write - write - read row hit\n    task_name = \"write - write - read - row hit\";\n    dq_en = 1'b1;\n    writing_1(prev_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n    read_with_verify(prev_addr, sch);\n    \n\n    //Case wait for refreshing refresh everything\n    task_name = \"refresh 150 cycles\";\n    repeat(150) @(posedge CLK);\n    //PASS CHECKPOINT\n\n    // For the purpose of checking the refresh command\n    // We will load the same address and observe\n    // 1. Command FSM IDLE -> ACT -> READ\n    // 2. Row policy is updated\n    read_with_verify(prev_addr, sch);\n\n    //Test case: Testing row miss case with 3 consecutive writes of random address\n    task_name = \"3 consectutive writing\";\n    dq_en = 1'b1;\n    //1 consectutive\n    sch.randomize();\n    sch.create_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n    //2 consectutive\n    sch.randomize();\n    sch.create_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n    //3 consectutive\n    sch.randomize();\n    sch.create_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n\n    //After that we use the last consecutive write to test the conflict case\n    task_name = \"Test row conflict write row hit read\";\n    don_t_write = 1'b1;\n    sch.create_addr(\"row conflict\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while(dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n    //This task is special because after 3 consecutive writes, and while reading, we jump into refresh request\n    task_name = \"Test row conflcit read (the old address that cause write)\";\n    read_with_verify(prev_addr, sch);\n    repeat(10) @(posedge CLK);\n\n\n    // // Checkpoint\n    // // 1. REFRESH timing too early, need to check again\n    // // 2. Something off with consecutive write 3 times in a row\n\n    $finish;\n\n    end\n\n    task add_request(input logic [31:0] addr, input logic write, input logic [31:0] data);\n      if (write) begin\n          sch_if.dWEN = 1'b1;\n          sch_if.dREN = 1'b0;\n          sch_if.ramaddr = addr;\n          sch_if.memstore = data;\n      end else begin\n          sch_if.dWEN = 1'b0;\n          sch_if.dREN = 1'b1;\n          sch_if.ramaddr = addr;\n      end\n      #(PERIOD);\n      // @(posedge CLK);\n      sch_if.dWEN = 1'b0;\n      sch_if.dREN = 1'b0;\n    endtask\nendmodule\n\nmodule sw_cache #( parameter ROW_BITS = 15)\n(\n    input logic CLKx2,\n    input logic nRST,\n    input logic wr_en,\n    input logic rd_en,\n    input logic [ROW_BITS-1:0] row_addr,\n    input logic [2:0] offset,\n    input logic [63:0] dmemstore,\n    output logic [63:0] dmemload\n);\n\n    typedef struct packed {\n        logic [7:0][63:0] arr;\n    } data_8bytes;\n\n    data_8bytes sw_cache [2**ROW_BITS-1:0];\n\n    always_ff @(posedge CLKx2, negedge nRST) begin\n        if(!nRST) begin\n            for (int i = 0; i < ROW_BITS; i++) begin\n                sw_cache[i] <= 0;\n            end\n        end else begin\n            if (wr_en) begin\n                sw_cache[row_addr].arr[offset] <= dmemstore;\n            end\n        end\n    end\n\n    always_comb begin\n        dmemload = 0;\n        if (rd_en) begin\n            dmemload = sw_cache[row_addr].arr[offset];\n        end\n    end\n\n\n\nendmodule","lang":"verilog"};
processSrcData(g_data);