var g_data = {"name":"./tb/dram_top_tb.sv","src":"`include \"dram_pkg.vh\"\n`include \"scheduler_buffer_if.vh\"\n`include \"data_transfer_if.vh\"\n`include \"control_unit_if.vh\"\n`include \"signal_gen_if.vh\"\n`include \"arch_defines.v\"\n`include \"dimm.vh\"\n`timescale 1 ns / 1 ps\n\n\n//Welcome to the mess, here is just a bunch of code that trying to verify DDR4!\n// 1. Test the power up state\n// 2. Test the refresh cycle \n// 3. Test row miss write row hit read\n// 4. Test row hit write row hit read\n// 5. Test the refresh and row miss read\n// 6. Test 3 consectutive  row miss write\n// 7. Test row conflict write (after 3 consecutive write, I write the conflict row into last row of consecutive writes) (REFRESH happened during writing)\n// 8. Test row conflcit read (the last consecutive addr conflict number 7)\n// 9. Test 16 consecutive write with different bank\n// 10. Test 1000 random read and write of different commands\n\n//RUNING SIMULATION: make dram_top\n\nmodule dram_top_tb;\n    parameter PERIOD = 1.5;\n    parameter tCK = 1.5;\n    import dram_pkg::*;\n    import proj_package::*;\n\n    //parameter from dram_command_if.vh\n    parameter CONFIGURED_DQ_BITS     = 8;\n    parameter CONFIGURED_DQS_BITS     = (16 == CONFIGURED_DQ_BITS) ? 2 : 1;\n    parameter CONFIGURED_DM_BITS     = (16 == CONFIGURED_DQ_BITS) ? 2 : 1;\n    parameter CONFIGURED_RANKS = 1;\n    \n    //CLK and debug signals\n    logic CLK = 1, nRST;\n    logic CLKx2=0;\n    reg model_enable_val;\n    string task_name;\n\n    //Instantiate the the iDDR4_1 version\n    reg clk_val, clk_enb;\n    logic DM_debug; //Used it if you want to debug with writing mask\n    assign model_enable = model_enable_val;\n\n    //Signal flag to choose write or read\n    reg dq_en;\n    reg dqs_en;\n    \n\n    //Cache signals and signals for verifying the data transmission\n    logic cache_write;\n    logic cache_read;\n    logic [ROW_BITS-1:0] cache_addr;\n    logic [2:0] cache_offset;\n    logic [63:0] cache_store;\n    logic [63:0] cache_load;\n    logic don_t_write; //Signals it use for telling whether you want to latch prev addr or not\n    logic [31:0] prev_addr; \n    \n    //Clock generation of CK and CKx2\n    //Issue right now, CK is follow TS_1500 tCK is 1.5ns\n    //I want to figure out a way that can change different configurations to choose TS_1500 (right now micron dram is TS_1250 - 1.25ns)\n    always begin\n        CLK = 1'b0;\n        #(PERIOD / 2.0);\n        CLK = 1'b1;\n        #(PERIOD / 2.0);\n    end\n\n    always begin\n        CLKx2 = 1'b1;\n        #(PERIOD / 4.0);\n        CLKx2 = 1'b0;\n        #(PERIOD / 4.0);\n    end\n\n    //Instantiate the interface of DRAM controller and DDR4 DRAM\n    control_unit_if dc_if();\n    signal_gen_if sig_if();\n    scheduler_buffer_if sch_if();\n    data_transfer_if dt_if();\n\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_1();\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_2();\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_3();\n    DDR4_if #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS)) iDDR4_4();\n\n    dram_top DUT (.CLK(CLK), .nRST(nRST), .myctrl(dc_if), .myctrl_sig(dc_if), .mysig(sig_if));\n    scheduler_buffer SCH_BUFF (.CLK(CLK), .nRST(nRST), .mysche(sch_if));\n    data_transfer DT (.CLK(CLK), .CLKx2(CLKx2),.nRST(nRST), .mydata(dt_if));\n\n    //Instantiate cache as a referrence model to verify data load\n    sw_cache CACHE (.CLKx2(CLKx2), .nRST(nRST), .wr_en(cache_write), .rd_en(cache_read), .row_addr(cache_addr), .offset(cache_offset), .dmemstore(cache_store), .dmemload(cache_load));\n\n    //Scheduler interface with the \n    always_comb begin\n      dc_if.dREN = (!dc_if.ram_wait) ? 0 : sch_if.ramREN_curr;\n      dc_if.dWEN = (!dc_if.ram_wait) ? 0 : sch_if.ramWEN_curr;\n      dc_if.ram_addr = sch_if.ramaddr_rq;\n      sch_if.request_done = !dc_if.ram_wait;\n      //Interface between scheduler buffer and the data_transfer\n      dt_if.wr_en = dc_if.wr_en;\n      dt_if.rd_en = dc_if.rd_en;\n    end\n\n    \n    //DRAM interface latch\n    always @(posedge clk_val && clk_enb) begin\n        clk_val <= #(tCK/2) 1'b0;\n        clk_val <= #(tCK) 1'b1;\n        iDDR4_1.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_1.CK[1] <= #(tCK) 1'b1;\n        iDDR4_1.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_1.CK[0] <= #(tCK) 1'b0;  \n\n        iDDR4_2.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_2.CK[1] <= #(tCK) 1'b1;\n        iDDR4_2.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_2.CK[0] <= #(tCK) 1'b0;\n\n        iDDR4_3.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_3.CK[1] <= #(tCK) 1'b1;\n        iDDR4_3.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_3.CK[0] <= #(tCK) 1'b0;\n\n        iDDR4_4.CK[1] <= #(tCK/2) 1'b0;\n        iDDR4_4.CK[1] <= #(tCK) 1'b1;\n        iDDR4_4.CK[0] <= #(tCK/2) 1'b1;\n        iDDR4_4.CK[0] <= #(tCK) 1'b0;\n\n\n        iDDR4_1.ACT_n     <= sig_if.ACT_n;\n        iDDR4_1.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_1.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_1.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_1.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_1.PARITY    <= sig_if.PARITY;\n        iDDR4_1.RESET_n   <= sig_if.RESET_n;\n        iDDR4_1.TEN       <= sig_if.TEN;\n        iDDR4_1.CS_n      <= sig_if.CS_n;\n        iDDR4_1.CKE       <= sig_if.CKE;\n        iDDR4_1.ODT       <= sig_if.ODT;\n        iDDR4_1.C         <= sig_if.C;\n        iDDR4_1.BG        <= sig_if.BG;\n        iDDR4_1.BA        <= sig_if.BA;\n        iDDR4_1.ADDR      <= sig_if.ADDR;\n        iDDR4_1.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_1.ZQ        <= sig_if.ZQ;\n        iDDR4_1.PWR       <= sig_if.PWR;\n        iDDR4_1.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_1.VREF_DQ   <= sig_if.VREF_DQ;\n\n        //DRAM 2\n        iDDR4_2.ACT_n     <= sig_if.ACT_n;\n        iDDR4_2.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_2.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_2.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_2.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_2.PARITY    <= sig_if.PARITY;\n        iDDR4_2.RESET_n   <= sig_if.RESET_n;\n        iDDR4_2.TEN       <= sig_if.TEN;\n        iDDR4_2.CS_n      <= sig_if.CS_n;\n        iDDR4_2.CKE       <= sig_if.CKE;\n        iDDR4_2.ODT       <= sig_if.ODT;\n        iDDR4_2.C         <= sig_if.C;\n        iDDR4_2.BG        <= sig_if.BG;\n        iDDR4_2.BA        <= sig_if.BA;\n        iDDR4_2.ADDR      <= sig_if.ADDR;\n        iDDR4_2.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_2.ZQ        <= sig_if.ZQ;\n        iDDR4_2.PWR       <= sig_if.PWR;\n        iDDR4_2.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_2.VREF_DQ   <= sig_if.VREF_DQ;\n\n        //DRAM 3\n        iDDR4_3.ACT_n     <= sig_if.ACT_n;\n        iDDR4_3.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_3.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_3.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_3.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_3.PARITY    <= sig_if.PARITY;\n        iDDR4_3.RESET_n   <= sig_if.RESET_n;\n        iDDR4_3.TEN       <= sig_if.TEN;\n        iDDR4_3.CS_n      <= sig_if.CS_n;\n        iDDR4_3.CKE       <= sig_if.CKE;\n        iDDR4_3.ODT       <= sig_if.ODT;\n        iDDR4_3.C         <= sig_if.C;\n        iDDR4_3.BG        <= sig_if.BG;\n        iDDR4_3.BA        <= sig_if.BA;\n        iDDR4_3.ADDR      <= sig_if.ADDR;\n        iDDR4_3.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_3.ZQ        <= sig_if.ZQ;\n        iDDR4_3.PWR       <= sig_if.PWR;\n        iDDR4_3.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_3.VREF_DQ   <= sig_if.VREF_DQ;\n\n        //DRAM 4\n        iDDR4_4.ACT_n     <= sig_if.ACT_n;\n        iDDR4_4.RAS_n_A16 <= sig_if.RAS_n_A16;\n        iDDR4_4.CAS_n_A15 <= sig_if.CAS_n_A15;\n        iDDR4_4.WE_n_A14  <= sig_if.WE_n_A14;\n        iDDR4_4.ALERT_n   <= sig_if.ALERT_n;\n        iDDR4_4.PARITY    <= sig_if.PARITY;\n        iDDR4_4.RESET_n   <= sig_if.RESET_n;\n        iDDR4_4.TEN       <= sig_if.TEN;\n        iDDR4_4.CS_n      <= sig_if.CS_n;\n        iDDR4_4.CKE       <= sig_if.CKE;\n        iDDR4_4.ODT       <= sig_if.ODT;\n        iDDR4_4.C         <= sig_if.C;\n        iDDR4_4.BG        <= sig_if.BG;\n        iDDR4_4.BA        <= sig_if.BA;\n        iDDR4_4.ADDR      <= sig_if.ADDR;\n        iDDR4_4.ADDR_17   <= sig_if.ADDR_17;\n        iDDR4_4.ZQ        <= sig_if.ZQ;\n        iDDR4_4.PWR       <= sig_if.PWR;\n        iDDR4_4.VREF_CA   <= sig_if.VREF_CA;\n        iDDR4_4.VREF_DQ   <= sig_if.VREF_DQ;\n    end\n\n    // Component instantiation\n    //Only use 4 chips only, so 32-bit data\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u0_r0(.model_enable(model_enable), .iDDR4(iDDR4_1));\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u1_r0(.model_enable(model_enable), .iDDR4(iDDR4_2));\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u2_r0(.model_enable(model_enable), .iDDR4(iDDR4_3));\n    ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u3_r0(.model_enable(model_enable), .iDDR4(iDDR4_4));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u4_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u4_r0));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u5_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u5_r0));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u6_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u6_r0));\n    // ddr4_model #(.CONFIGURED_DQ_BITS(CONFIGURED_DQ_BITS),  .CONFIGURED_RANKS(CONFIGURED_RANKS)) u7_r0(.model_enable(model_enable), .iDDR4(iDDR4_1.u7_r0));\n\n    //Interface between iDDR4 and data transfer example\n    // Connect DQ, DQS_t, DQS_c, DM_n\n    // Note DM_n is the signal for the writing mask\n    assign {\n        iDDR4_1.DQ,\n        iDDR4_2.DQ,\n        iDDR4_3.DQ,\n        iDDR4_4.DQ\n    } = dq_en ? {dt_if.DQ} : {32{1'bz}};\n\n\n    assign {\n        iDDR4_1.DQS_t,\n        iDDR4_2.DQS_t,\n        iDDR4_3.DQS_t,\n        iDDR4_4.DQS_t\n    } = dq_en ? {dt_if.DQS_t,\n                 dt_if.DQS_t,\n                 dt_if.DQS_t,\n                 dt_if.DQS_t  \n                 } : 4'bzz;\n\n    assign {\n        iDDR4_1.DQS_c,\n        iDDR4_2.DQS_c,\n        iDDR4_3.DQS_c,\n        iDDR4_4.DQS_c\n    } = dq_en ? {\n        dt_if.DQS_c,\n        dt_if.DQS_c,\n        dt_if.DQS_c,\n        dt_if.DQS_c\n        } : 4'bzz;\n\n    //Writing mask feature\n    assign {\n        iDDR4_1.DM_n,\n        iDDR4_2.DM_n,\n        iDDR4_3.DM_n,\n        iDDR4_4.DM_n\n    } = dq_en ? {\n        dt_if.DM_n,\n        dt_if.DM_n,\n        dt_if.DM_n,\n        dt_if.DM_n\n    } : 4'bzz;\n\n\n    assign dt_if.DQ = ~dq_en ? {\n        iDDR4_1.DQ,\n        iDDR4_2.DQ,\n        iDDR4_3.DQ,\n        iDDR4_4.DQ\n    } : {32{1'bz}};\n\n    //Assign these DQ signals back with data transfer (bidirectional)\n    assign dt_if.DQS_t = ~dq_en ? iDDR4_1.DQS_t : 1'bz;\n    assign dt_if.DQS_c = ~dq_en ? iDDR4_1.DQS_c: 1'bz;\n    assign dt_if.DM_n = ~dq_en ? iDDR4_1.DM_n: 1'bz;\n    assign dt_if.COL_choice = dc_if.offset; \n\n    //Latch for the prev_addr, I use this for row hit, row conflict case\n    always_ff @(posedge CLK) begin\n        if (!nRST) begin\n            prev_addr <= 0;\n        end else begin\n            if (!don_t_write) begin\n                prev_addr <= sch.creating_addr;\n            end\n        end\n    end\n\n    //Creating class for the transaction\n    class sche_trans;\n        //Getting the scheduler buffer interface\n        virtual scheduler_buffer_if vif;\n\n        //Random rank, bank group, bank, row, col, offset\n        rand logic [RANK_BITS - 1:0] rank;\n        // randc logic [BANK_GROUP_BITS - 1:0] BG;\n        // randc logic [BANK_BITS - 1:0] bank;\n        rand logic [BANK_GROUP_BITS - 1:0] BG;\n        rand logic [BANK_BITS - 1:0] bank;\n        rand logic [ROW_BITS - 1:0] row;\n        rand logic [COLUMN_BITS - 1:0] col;\n        rand logic [OFFSET_BITS - 1:0] offset;\n\n        logic [31:0] creating_addr; //the actual address\n\n\n        //1. Creating covergroup (IGNORE THIS)\n        covergroup sch_group @(posedge CLK);\n            //2.Creating coverpoint\n            sch_point : coverpoint {vif.dREN, vif.dWEN} {\n                bins s00 = {2'b00};\n                bins s10 = {2'b10};\n                bins s01 = {2'b01};\n            }\n        endgroup        \n\n        //3. Creating the constraint\n        //dREN and dWEN should never goes high at the same time\n        constraint req_cons {\n            {vif.dREN, vif.dWEN} != 2'b11;\n        }\n\n        //constraint of addr_rank\n        constraint addr_rank {\n            rank == 1'b0;\n            row != '1;\n            offset == 0;\n            col[2:0] == 0; //8-byte align\n        }\n\n        function new (virtual scheduler_buffer_if vif);\n            this.vif = vif;\n            sch_group = new();\n        endfunction\n\n        //function for generate the address\n        function gen_addr (string testcase, input logic[31:0] prev_addr);\n            //If you want to add row conflict\n            if (testcase == \"row conflict\") begin\n                creating_addr = prev_addr;\n                creating_addr[30:17] = '1;\n            end else if (testcase == \"row hit\") begin\n                creating_addr = prev_addr;\n            end else begin\n                creating_addr = {rank, row, bank, BG[1], col[9:3], BG[0], col[2:0], offset};\n            end\n        endfunction\n    endclass\n\n    //Class for generate data (This is not necessary)\n    class creating_dt;\n        rand logic [31:0] data_store;\n        function new ();\n\n        endfunction\n        function display;\n            $display (\"data_store %0x\", data_store);\n        endfunction\n    endclass\n\n    //Define class\n    creating_dt dt_class;   \n    sche_trans sch;\n\n    //Use this task to add a request into scheduler FIFO\n    task add_request(input logic [31:0] addr, input logic write, input logic [31:0] data);\n      if (write) begin\n          sch_if.dWEN = 1'b1;\n          sch_if.dREN = 1'b0;\n          sch_if.ramaddr = addr;\n          sch_if.memstore = data;\n      end else begin\n          sch_if.dWEN = 1'b0;\n          sch_if.dREN = 1'b1;\n          sch_if.ramaddr = addr;\n      end\n      #(PERIOD);\n      sch_if.dWEN = 1'b0;\n      sch_if.dREN = 1'b0;\n    endtask\n\n    //This is the task you want to write something in a specific addr\n    //Don't worry about the data context\n    task writing_1(input logic [31:0] addr, input creating_dt dt_class);\n        begin\n        add_request(.addr(addr), .write(1'b1), .data(32'hAAAA_AAAA));\n        while (!dt_if.wr_en) begin\n            @(posedge CLK);\n        end\n\n        //This loop will wriete\n        for (int i = 0; i < 9; i++) begin\n            dt_class.randomize();\n            // dt_class.display();\n            dt_if.memstore = dt_class.data_store;\n            // $display (\"Here is  i : %0x, and memstore: %0x\", i, dt_class.data_store);\n            if (i != 0) begin\n                cache_addr = addr[30:16];\n                cache_write = 1'b1;\n                cache_store = dt_class.data_store;\n                cache_offset = i - 1;\n            end\n            @(posedge CLKx2);\n        end\n        dt_if.clear = 1'b1; //Should not be here, check later this\n        cache_write = 1'b0;\n        @(posedge CLK);\n        dt_if.clear = 1'b0;\n        end\n    endtask\n\n    //A random testing case\n    task writing_read_row_hit(input creating_dt dt_class);\n        task_name = \"Writing_Cycle\";\n        //Case 2 check the writing cycle\n        //Case checking the writing burst\n        //Creating new addr\n        sch.randomize();\n        sch.gen_addr(\"row miss\", prev_addr);\n        writing_1(sch.creating_addr, dt_class);\n        repeat (50) @(posedge CLK);\n\n        task_name = \"Reading_Cycle\";\n        dq_en = 1'b0;\n        //Case 3 check the reading cycle\n        add_request(.addr(sch.creating_addr), .write(1'b0), .data(32'hAAAA_AAAA));\n        repeat (50) @(posedge CLK);\n    endtask\n\n    //This is the task where you want to read the address and verify with cache model\n    task read_with_verify (\n        input logic [31:0] addr,\n        input sche_trans sch\n    );\n        dq_en = 0;\n        add_request(.addr(addr), .write(1'b0), .data(32'hAAAA_AAAA));\n        while (dc_if.ram_wait) begin\n            cache_read = 1;\n            cache_addr = addr[30:16];\n            if (dt_if.edge_flag) begin\n                cache_offset = cache_offset + 1;\n                @(posedge CLKx2);\n            end else begin\n                cache_offset = 0;\n                @(posedge CLKx2);\n            end\n        end\n        dq_en = 1;\n        cache_read = 1;\n        dt_if.clear = 0;\n    endtask\n    //Creating the assert to check the failed case of data load\n    property wr_verify;\n        @(posedge CLK) disable iff (!nRST)\n        dt_if.rd_en && (dt_if.edge_flag) |-> (cache_load == dt_if.memload);\n    endproperty\n    assert property (wr_verify)\n    else \n        //If failed it should stop simulation\n        $fatal(\"Time: [%0t], Addr: %0x, offset: %0x, cache load: %0x, dt_memload: %0x\",$time,sch.creating_addr[30:16], cache_offset, cache_load, dt_if.memload);\n\n\n    //Task of writing different 16 writes of different banks\n    task consecutive_16_write();\n        for (int i = 0; i < 16; i++) begin\n            task_name = $sformatf(\"16 write-dif bank  -%0d\", i);\n            dq_en = 1'b1;\n            sch.randomize();\n            sch.gen_addr(\"row miss\", prev_addr);\n            writing_1(sch.creating_addr, dt_class);\n            while (dc_if.ram_wait) begin\n                @(posedge CLK);\n            end\n        end\n    endtask\n\n    //1000 request come one by one\n    task random_req();\n        bit wr_or_rd; \n        for (int i = 0; i < 1000; i++) begin\n            task_name = $sformatf(\"Task random -%0d\", i);\n            wr_or_rd = $urandom_range(0,1); // simple 0/1;\n            if (wr_or_rd) begin\n                dq_en = 1'b1;\n                sch.randomize();\n                sch.gen_addr(\"row miss\", prev_addr);\n                writing_1(sch.creating_addr, dt_class);\n                while (dc_if.ram_wait) begin\n                    @(posedge CLK);\n                end\n            end else begin\n                dq_en = 1'b0;\n                read_with_verify(sch.creating_addr, sch);\n            end \n        end\n    endtask\n\n    initial begin\n      iDDR4_1.CK = 2'b01;\n      clk_enb = 1'b1;\n      clk_val = 1'b1;  \n      model_enable_val = 1;\n      dq_en = 1'b1;\n      don_t_write = 0;\n      \n      //Cache\n      cache_addr = 0;\n      cache_write = 0;\n      cache_read = 0;\n      cache_offset = 0;\n      cache_store = 0;\n      \n      \n      dt_class = new();\n      sch = new(sch_if);\n      nRST = 1'b0;\n      @(posedge CLK);\n      @(posedge CLK);\n      nRST = 1'b1;\n\n      \n      task_name = \"Power_up\";\n      #((tRESET + tPWUP + tRESETCKE + tPDc + tXPR + tDLLKc + tMOD * 7 + tZQinitc) * PERIOD);\n      repeat (25) @(posedge CLK);\n\n    \n    \n    task_name = \"Writing_Cycle\";\n    sch.randomize();\n    sch.gen_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    repeat (50) @(posedge CLK);\n\n    \n    task_name = \"Reading_Cycle\";\n    dq_en = 1'b0;\n    read_with_verify(sch.creating_addr, sch);\n    \n    \n    //checking the write - write - read row hit\n    task_name = \"write - write - read - row hit\";\n    dq_en = 1'b1;\n    writing_1(prev_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n    read_with_verify(prev_addr, sch);\n    \n\n    //Case wait for refreshing refresh everything\n    task_name = \"refresh 150 cycles\";\n    repeat(150) @(posedge CLK);\n    //PASS CHECKPOINT\n\n    // For the purpose of checking the refresh command\n    // We will load the same address and observe\n    // 1. Command FSM IDLE -> ACT -> READ\n    // 2. Row policy is updated\n    read_with_verify(prev_addr, sch);\n\n    //Test case: Testing row miss case with 3 consecutive writes of random address\n    task_name = \"3 consectutive writing\";\n    dq_en = 1'b1;\n    //1 consectutive\n    sch.randomize();\n    sch.gen_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n    //2 consectutive\n    sch.randomize();\n    sch.gen_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n    //3 consectutive\n    task_name = \"The last consecutive write of the testcase\";\n    sch.randomize();\n    sch.gen_addr(\"row miss\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while (dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n\n    //After that we use the last consecutive write to test the conflict case\n    task_name = \"Test row conflict write row hit read\";\n    don_t_write = 1'b1;\n    sch.gen_addr(\"row conflict\", prev_addr);\n    writing_1(sch.creating_addr, dt_class);\n    while(dc_if.ram_wait) begin\n        @(posedge CLK);\n    end\n    repeat(10) @(posedge CLK);\n\n    //This task is special because after 3 consecutive writes, and while reading, we jump into refresh request\n    task_name = \"Test row conflcit read (the old address that cause write)\";\n    read_with_verify(prev_addr, sch);\n    repeat(200) @(posedge CLK);\n\n    //Task 16_consecutive writes\n    task_name = \"16 write-dif bank\";\n    consecutive_16_write();\n\n    //Task random\n    random_req();\n\n    //CHECKPOINT: DONE ALL PREVIOUS CASES\n    //TODO may be: the writing burst mask cases doesn't have general test cases\n    $finish;\n    end\nendmodule\n\n\n//Reference cache for verification\n//Use to store 64byte of data in different rows\nmodule sw_cache #( parameter ROW_BITS = 15)\n(\n    input logic CLKx2,\n    input logic nRST,\n    input logic wr_en,\n    input logic rd_en,\n    input logic [ROW_BITS-1:0] row_addr,\n    input logic [2:0] offset,\n    input logic [63:0] dmemstore,\n    output logic [63:0] dmemload\n);\n\n    typedef struct packed {\n        logic [7:0][63:0] arr;\n    } data_8bytes;\n\n    data_8bytes sw_cache [2**ROW_BITS-1:0];\n\n    always_ff @(posedge CLKx2, negedge nRST) begin\n        if(!nRST) begin\n            for (int i = 0; i < ROW_BITS; i++) begin\n                sw_cache[i] <= 0;\n            end\n        end else begin\n            if (wr_en) begin\n                sw_cache[row_addr].arr[offset] <= dmemstore;\n            end\n        end\n    end\n\n    always_comb begin\n        dmemload = 0;\n        if (rd_en) begin\n            dmemload = sw_cache[row_addr].arr[offset];\n        end\n    end\nendmodule","lang":"verilog"};
processSrcData(g_data);