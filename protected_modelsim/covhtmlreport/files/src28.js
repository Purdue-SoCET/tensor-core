var g_data = {"name":"./src/data_transfer.sv","src":"`include \"data_transfer_if.vh\"\n`include \"edge_det_if.vh\"\n`include \"dram_command_if.vh\"\n\nmodule data_transfer (\n    input logic CLK,\n    input logic CLKx2,\n    input logic nRST,\n    data_transfer_if.data_trans mydata\n);\n    import dram_pack::*;\n    parameter BURST = 8;\n    edge_det_if myedge();\n    logic [3:0] count_burst, ncount_burst, cnt1;\n    logic wr_en1, wr_en2; //We may need this to latch then count the burst\n    \n    logic select_low;\n    logic [CONFIGURED_DQS_BITS - 1 : 0] DQS_t_1, DQS_t_2, nDQS_t;\n    // logic edge_flag;\n    logic [3:0] COL_choice_tr;\n    \n    \n    //WRITING CASE: \n    logic [31:0] DQ_up, D_in, D_out, D_mux;\n    logic [7:0][31:0] word_register;\n    //READING CASE:\n\n\n    assign mydata.DQ = (mydata.wr_en) ?    DQ_up : 'z;\n    assign mydata.DQS_t = (mydata.wr_en) ? DQS_t_2 : 'z;\n    assign mydata.DQS_c = (mydata.wr_en) ? ~DQS_t_2 : 'z;\n    // assign mydata.DM_n = (mydata.wr_en) ? (count_burst == COL_choice_tr) : 1'bz;\n    assign mydata.DM_n = (mydata.wr_en) ? 1 : 1'bz;\n    // assign mydata.memload = (count_burst == (BURST + 4'd2)) ? word_register[mydata.COL_choice] : '0;\n    assign COL_choice_tr = mydata.COL_choice + 4'd4; \n\n\n    //Interface between DQS_t and the edge_det\n    assign myedge.async_in = mydata.DQS_t; \n    assign mydata.edge_flag = myedge.edge_flag;   \n\n    edge_det #(.TRIG_RISE(1'b1), .TRIG_FALL(1'b1)) u0 (.clk(CLKx2), .n_rst(nRST), .myedge(myedge));\n\n    always_ff @(posedge CLKx2, negedge nRST) begin\n        if (!nRST) begin\n            count_burst <= '0;\n            cnt1 <= '0;\n            DQS_t_2 <= 1;\n        end else begin\n            if (mydata.wr_en) begin\n                count_burst <= ncount_burst;\n                cnt1 <= count_burst;\n                DQS_t_2 = nDQS_t;\n            end else if (mydata.rd_en) begin\n                count_burst <= ncount_burst;\n                DQS_t_2 = nDQS_t;\n            end else begin\n                count_burst <= 0;\n                DQS_t_2 = 1;\n            end\n            // if (mydata.clear) begin\n            //     count_burst <= '0;\n            // end\n            \n        end\n    end\n\n    \n\n\n    always_ff @(negedge CLKx2, negedge nRST) begin //BURST_EVEN\n        if (!nRST) begin\n            DQ_up <= '0;\n        end else begin\n            if (mydata.wr_en && (count_burst >= 4'd3)) begin\n                DQ_up <= mydata.memstore;    \n            end\n            \n        end\n    end\n\n\n    always_ff @(posedge CLKx2, negedge nRST) begin\n        if (!nRST) begin\n            word_register <= '0;\n        end else begin \n            //This is something we need to change\n            if (mydata.rd_en && mydata.edge_flag) begin\n                word_register[count_burst - 4'd2] <= mydata.DQ;\n                // if (count_burst > 4'd1) begin\n                //     word_register[count_burst - 4'd2] <= mydata.DQ;\n                // end\n            end\n        end\n    end\n\n    \n    \n    always_comb begin\n        ncount_burst = count_burst;\n        nDQS_t = DQS_t_2;\n        mydata.memload = 0;\n        if (count_burst >= 3'd2) begin\n            nDQS_t = ~DQS_t_2;\n        end\n        if (mydata.wr_en || mydata.rd_en) begin\n            ncount_burst = count_burst + 4'd1;        \n        end \n\n        if (mydata.clear) begin\n            ncount_burst = '0;\n        end\n\n        if (mydata.edge_flag) mydata.memload = mydata.DQ;\n    end\nendmodule","lang":"verilog"};
processSrcData(g_data);