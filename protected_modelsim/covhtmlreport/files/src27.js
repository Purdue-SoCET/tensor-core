var g_data = {"name":"./src/scheduler_buffer.sv","src":"`include \"scheduler_buffer_if.vh\"\n`include \"socetlib_counter_if.vh\"\n\n\nmodule scheduler_buffer #(\n    parameter WORD_W = 32\n) (\n    input logic CLK,\n    input logic nRST,\n    scheduler_buffer_if.scheduler mysche \n);\n\n    logic [6:0] wptr, rptr;\n    logic clear, flush;\n    logic full;\n    integer i;\n    // logic [1:0][WORD_W : 0] [64:0]fifo;\n    // logic [1:0][WORD_W : 0] [64:0]n_fifo;\n\n    logic [64:0][1:0][WORD_W + 1:0] fifo, n_fifo;\n\n    assign mysche.ramaddr_rq = fifo[rptr][0][31:0];\n    assign mysche.ramaddr_rq_ft = fifo[rptr - 1][0][31:0];\n    assign mysche.ramstore_rq = fifo[rptr][1][31:0];\n    assign mysche.ramstore_rq_ft = fifo[rptr - 1][1][31:0];\n    \n    assign mysche.ramREN_curr = fifo[rptr][0][33:32] == 2'b01 ? 1'b1 : 1'b0;\n    assign mysche.ramREN_ftrt = fifo[rptr - 1][0][32] == 2'b01 ? 1'b1 : 1'b0;\n\n    assign mysche.ramWEN_curr = fifo[rptr][0][33:32] == 2'b10 ? 1'b1 : 1'b0;\n    assign mysche.ramWEN_ftrt = fifo[rptr - 1][0][32] == 2'b10 ? 1'b1 : 1'b0;\n\n\n    assign full = (wptr == (rptr - 1)) ? 1'b1: 1'b0;\n    \n\n    \n    \n    socetlib_counter #(.NBITS(7)) write_count (.CLK(CLK), .nRST(nRST), .clear(clear|| flush), .count_enable((mysche.dWEN || mysche.dREN) && ~full), .overflow_val(7'd64), .count_out(wptr));\n    socetlib_counter #(.NBITS(7)) read_count (.CLK(CLK), .nRST(nRST), .clear(clear|| flush), .count_enable(mysche.request_done && ~full), .overflow_val(7'd64), .count_out(rptr));\n\n\n    always_ff @(posedge CLK, negedge nRST) begin\n        if (!nRST) begin\n            fifo <= '0;\n        end else begin\n            for (int i = 0; i < 65; i++) begin\n                fifo[i] <= n_fifo[i];\n            end\n        end\n    end\n\n\n    always_comb begin\n        clear = 1'b0;\n        flush = 1'b0;\n        for (i = 0; i < 65; i++) begin\n            n_fifo[i] = fifo[i];\n        end\n\n        if (mysche.dREN) begin\n            n_fifo[wptr][0] = {2'b01, mysche.ramaddr};\n        end else if (mysche.dWEN) begin\n            n_fifo[wptr][0] = {2'b10,mysche.ramaddr};\n            n_fifo[wptr][1] = mysche.memstore;\n        end\n\n        if (mysche.request_done) begin\n            n_fifo[rptr] = '0;\n            mysche.memaddr_callback = fifo[rptr][0]; \n        end\n\n        if (clear) begin\n            for (i = 0; i < 65; i++) begin\n                n_fifo[i] = '0;\n            end\n        end\n    end\n\nendmodule","lang":"verilog"};
processSrcData(g_data);